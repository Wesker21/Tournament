diff --git a/aCis_gameserver/config/Mods/Tournament.ini b/aCis_gameserver/config/Mods/Tournament.ini
new file mode 100644
index 0000000..95364c3
--- /dev/null
+++ b/aCis_gameserver/config/Mods/Tournament.ini
@@ -0,0 +1,157 @@
+# ================================================
+# 				TOURNAMENT  (by Rouxy)
+# ================================================
+# Tournament event duration in minutes
+TournamentDuration = 5
+# Tournament start times
+TournamentStartTime = 12:00,20:00
+
+# Npc Register Id
+TournamentNpcId = 50009
+
+# Npc register tournament coords
+TournamentNpcLocation = 150086,46733,-3412
+
+# Debug enabled
+Debug = True
+
+# List of restricted items in tournament
+ItemRestrictedList = 57
+
+# List of restricted skills in tournament
+SkillRestrictedList = 360
+
+# Time in seconds between search fights
+TimeBetweenSearchFights = 5
+
+# Time that teams will be teleported to arena in seconds
+TeleportFightTime = 10
+
+# Winner team rewards 
+# item1,count1;item2,count2;
+WinnerRewards = 57,1000;3470,10
+
+# Looser team rewards 
+# item1,count1;item2,count2;
+LooserRewards 57,500;3470,5
+
+# Start battle times in seconds
+FightStartTime_1x1 = 10
+FightStartTime_2x2 = 10
+FightStartTime_3x3 = 10
+FightStartTime_4x4 = 10
+FightStartTime_5x5 = 10
+FightStartTime_9x9 = 10
+
+# Battle duration in minutes
+FightDuration_1x1 = 1
+FightDuration_2x2 = 1
+FightDuration_3x3 = 1
+FightDuration_4x4 = 1
+FightDuration_5x5 = 1
+FightDuration_9x9 = 1
+
+# Fight classes restrictions
+# ARCHERS
+ArchersCountAllowed_1x1 = 1
+ArchersCountAllowed_2x2 = 1
+ArchersCountAllowed_3x3 = 1
+ArchersCountAllowed_4x4 = 1
+ArchersCountAllowed_5x5 = 1
+ArchersCountAllowed_9x9 = 1
+
+# ARCHMAGES
+ArchmagesCountAllowed_1x1 = 1
+ArchmagesCountAllowed_2x2 = 1
+ArchmagesCountAllowed_3x3 = 1
+ArchmagesCountAllowed_4x4 = 1
+ArchmagesCountAllowed_5x5 = 1
+ArchmagesCountAllowed_9x9 = 1
+
+# DAGGERS
+DaggersCountAllowed_1x1 = 1
+DaggersCountAllowed_2x2 = 1
+DaggersCountAllowed_3x3 = 1
+DaggersCountAllowed_4x4 = 1
+DaggersCountAllowed_5x5 = 1
+DaggersCountAllowed_9x9 = 1
+
+# DOMINATORS
+DominatorsCountAllowed_1x1 = 1
+DominatorsCountAllowed_2x2 = 1
+DominatorsCountAllowed_3x3 = 1
+DominatorsCountAllowed_4x4 = 1
+DominatorsCountAllowed_5x5 = 1
+DominatorsCountAllowed_9x9 = 1
+
+# DOOMCRYERS
+DoomcryersCountAllowed_1x1 = 1
+DoomcryersCountAllowed_2x2 = 1
+DoomcryersCountAllowed_3x3 = 1
+DoomcryersCountAllowed_4x4 = 1
+DoomcryersCountAllowed_5x5 = 1
+DoomcryersCountAllowed_9x9 = 1
+
+# DREADNOUGHTS
+DreadnoughtsCountAllowed_1x1 = 1
+DreadnoughtsCountAllowed_2x2 = 1
+DreadnoughtsCountAllowed_3x3 = 1
+DreadnoughtsCountAllowed_4x4 = 1
+DreadnoughtsCountAllowed_5x5 = 1
+DreadnoughtsCountAllowed_9x9 = 1
+
+# DUELISTS 
+DuelistsCountAllowed_1x1 = 1
+DuelistsCountAllowed_2x2 = 1
+DuelistsCountAllowed_3x3 = 1
+DuelistsCountAllowed_4x4 = 1
+DuelistsCountAllowed_5x5 = 1
+DuelistsCountAllowed_9x9 = 1
+
+# HEALERS
+HealersCountAllowed_1x1 = 1
+HealersCountAllowed_2x2 = 1
+HealersCountAllowed_3x3 = 1
+HealersCountAllowed_4x4 = 1
+HealersCountAllowed_5x5 = 1
+HealersCountAllowed_9x9 = 1
+
+# MYSTIC MUSES 
+MysticMusesCountAllowed_1x1 = 1
+MysticMusesCountAllowed_2x2 = 1
+MysticMusesCountAllowed_3x3 = 1
+MysticMusesCountAllowed_4x4 = 1
+MysticMusesCountAllowed_5x5 = 1
+MysticMusesCountAllowed_9x9 = 1
+
+# SOULTAKERS
+SoulTakersCountAllowed_1x1 = 1
+SoulTakersCountAllowed_2x2 = 1
+SoulTakersCountAllowed_3x3 = 1
+SoulTakersCountAllowed_4x4 = 1
+SoulTakersCountAllowed_5x5 = 1
+SoulTakersCountAllowed_9x9 = 1
+
+# TITANS
+TitansCountAllowed_1x1 = 1
+TitansCountAllowed_2x2 = 1
+TitansCountAllowed_3x3 = 1
+TitansCountAllowed_4x4 = 1
+TitansCountAllowed_5x5 = 1
+TitansCountAllowed_9x9 = 1
+
+# STORMSCREAMERS
+StormScreamersCountAllowed_1x1 = 1
+StormScreamersCountAllowed_2x2 = 1
+StormScreamersCountAllowed_3x3 = 1
+StormScreamersCountAllowed_4x4 = 1
+StormScreamersCountAllowed_5x5 = 1
+StormScreamersCountAllowed_9x9 = 1
+
+# TANKERS
+TankersCountAllowed_1x1 = 1
+TankersCountAllowed_2x2 = 1
+TankersCountAllowed_3x3 = 1
+TankersCountAllowed_4x4 = 1
+TankersCountAllowed_5x5 = 1
+TankersCountAllowed_9x9 = 1
diff --git a/aCis_gameserver/java/net/sf/l2j/Config.java b/aCis_gameserver/java/net/sf/l2j/Config.java
index 52a78be..c307f2e 100644
--- a/aCis_gameserver/java/net/sf/l2j/Config.java
+++ b/aCis_gameserver/java/net/sf/l2j/Config.java
@@ -16,7 +16,10 @@
 import net.sf.l2j.commons.math.MathUtil;
 
 import net.sf.l2j.gameserver.enums.GeoType;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
 import net.sf.l2j.gameserver.model.holder.IntIntHolder;
+import net.sf.l2j.gameserver.model.location.Location;
+import net.sf.l2j.util.RewardHolder;
 
 /**
  * This class contains global server configuration.<br>
@@ -37,7 +40,7 @@
 	public static final String SIEGE_FILE = "./config/siege.properties";
 	
 	public static final String SPECIAL_MODS = "./config/Mods/SpecialMods.ini";
-	
+	public static final String TOURNAMENT = "./config/Mods/Tournament.ini";
 	
 	/** Special Mods */
 	public static boolean RESTART_BY_TIME_OF_DAY;
@@ -46,6 +49,38 @@
 	 
 	public static boolean ALT_OLY_END_ANNOUNCE;
 	
+	/** Tournament */
+	public static final boolean DEBUG = false;
+	
+	public static int TOURNAMENT_EVENT_DURATION;
+	
+	public static String[] TOURNAMENT_EVENT_INTERVAL_BY_TIME_OF_DAY;
+	public static int TOURNAMENT_NPC_ID;
+	public static Location TOURNAMENT_NPC_LOCATION;
+	public static List<Integer> TOURNAMENT_RESTRICTED_SKILL_LIST = new ArrayList<>();
+	public static List<Integer> TOURNAMENT_RESTRICTED_ITEM_LIST = new ArrayList<>();
+	public static int TOURNAMENT_TIME_SEARCH_FIGHTS;
+	public static List<RewardHolder> TOURNAMENT_FIGHT_REWARD_WINNER = new ArrayList<>();
+	public static List<RewardHolder> TOURNAMENT_FIGHT_REWARD_LOOSER = new ArrayList<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_FIGHT_START_TIME = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_FIGHT_DURATION = new HashMap<>();
+	public static int TOURNAMENT_TIME_TO_TELEPORT;
+	public static boolean TOURNAMENT_DEBUG;
+	
+	public static Map<TournamentFightType, Integer> TOURNAMENT_DUELIST_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_DREADNOUGHT_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_TANKER_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_DAGGER_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_ARCHER_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_HEALER_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_ARCHMAGE_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_SOULTAKER_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_MYSTICMUSE_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_STORMSCREAMER_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_TITAN_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_DOMINATOR_ALLOWED = new HashMap<>();
+	public static Map<TournamentFightType, Integer> TOURNAMENT_DOOMCRYER_ALLOWED = new HashMap<>();
+
 	// --------------------------------------------------
 	// Clans settings
 	// --------------------------------------------------
@@ -1117,6 +1152,284 @@
 		ALT_OLY_END_ANNOUNCE = Boolean.parseBoolean(SpecialMods.getProperty("AltOlyEndAnnounce", "False"));
 	}
 	
+
+	private static final void loadTournament()
+	{
+		final ExProperties tournament = initProperties(TOURNAMENT);
+		
+		String[] npcLoc = tournament.getProperty("TournamentNpcLocation", "150086,46733,-3412").split(",");
+		TOURNAMENT_NPC_ID = tournament.getProperty("TournamentNpcId", 50009);
+		TOURNAMENT_NPC_LOCATION = new Location(Integer.parseInt(npcLoc[0]), Integer.parseInt(npcLoc[1]), Integer.parseInt(npcLoc[2]));
+		TOURNAMENT_EVENT_INTERVAL_BY_TIME_OF_DAY = tournament.getProperty("TournamentStartTime", "20:00").split(",");
+		TOURNAMENT_EVENT_DURATION = tournament.getProperty("TournamentDuration", 5);
+		for (String item : tournament.getProperty("ItemRestrictedList", "").split(","))
+		{
+			TOURNAMENT_RESTRICTED_ITEM_LIST.add(Integer.parseInt(item));
+		}
+		for (String skill : tournament.getProperty("SkillRestrictedList", "").split(","))
+		{
+			TOURNAMENT_RESTRICTED_SKILL_LIST.add(Integer.parseInt(skill));
+		}
+		TOURNAMENT_TIME_SEARCH_FIGHTS = tournament.getProperty("TimeBetweenSearchFights", 5);
+		TOURNAMENT_DEBUG = tournament.getProperty("Debug", true);
+		TOURNAMENT_TIME_TO_TELEPORT = tournament.getProperty("TeleportFightTime", 10);
+		TOURNAMENT_FIGHT_REWARD_WINNER.clear();
+		for (String s : tournament.getProperty("WinnerRewards", "57,1000;3470,10").split(";"))
+		{
+			String[] reward = s.split(",");
+			
+			RewardHolder simpleReward = new RewardHolder(Integer.parseInt(reward[0]), Integer.parseInt(reward[1]));
+			TOURNAMENT_FIGHT_REWARD_WINNER.add(simpleReward);
+		}
+		TOURNAMENT_FIGHT_REWARD_LOOSER.clear();
+		for (String s : tournament.getProperty("LooserRewards", "57,500;3470,5").split(";"))
+		{
+			String[] reward = s.split(",");
+			
+			RewardHolder simpleReward = new RewardHolder(Integer.parseInt(reward[0]), Integer.parseInt(reward[1]));
+			TOURNAMENT_FIGHT_REWARD_LOOSER.add(simpleReward);
+		}
+		
+		TOURNAMENT_FIGHT_START_TIME.clear();
+		int startTime1x1 = tournament.getProperty("FightStartTime_1x1", 10);
+		int startTime2x2 = tournament.getProperty("FightStartTime_2x2", 10);
+		int startTime3x3 = tournament.getProperty("FightStartTime_3x3", 10);
+		int startTime4x4 = tournament.getProperty("FightStartTime_4x4", 10);
+		int startTime5x5 = tournament.getProperty("FightStartTime_5x5", 10);
+		int startTime9x9 = tournament.getProperty("FightStartTime_9x9", 10);
+		
+		TOURNAMENT_FIGHT_START_TIME.put(TournamentFightType.F1X1, startTime1x1);
+		TOURNAMENT_FIGHT_START_TIME.put(TournamentFightType.F2X2, startTime2x2);
+		TOURNAMENT_FIGHT_START_TIME.put(TournamentFightType.F3X3, startTime3x3);
+		TOURNAMENT_FIGHT_START_TIME.put(TournamentFightType.F4X4, startTime4x4);
+		TOURNAMENT_FIGHT_START_TIME.put(TournamentFightType.F5X5, startTime5x5);
+		TOURNAMENT_FIGHT_START_TIME.put(TournamentFightType.F9X9, startTime9x9);
+		
+		TOURNAMENT_FIGHT_DURATION.clear();
+		int fightTime1x1 = tournament.getProperty("FightDuration_1x1", 1);
+		int fightTime2x2 = tournament.getProperty("FightDuration_2x2", 1);
+		int fightTime3x3 = tournament.getProperty("FightDuration_3x3", 1);
+		int fightTime4x4 = tournament.getProperty("FightDuration_4x4", 1);
+		int fightTime5x5 = tournament.getProperty("FightDuration_5x5", 1);
+		int fightTime9x9 = tournament.getProperty("FightDuration_9x9", 1);
+		
+		TOURNAMENT_FIGHT_DURATION.put(TournamentFightType.F1X1, fightTime1x1);
+		TOURNAMENT_FIGHT_DURATION.put(TournamentFightType.F2X2, fightTime2x2);
+		TOURNAMENT_FIGHT_DURATION.put(TournamentFightType.F3X3, fightTime3x3);
+		TOURNAMENT_FIGHT_DURATION.put(TournamentFightType.F4X4, fightTime4x4);
+		TOURNAMENT_FIGHT_DURATION.put(TournamentFightType.F5X5, fightTime5x5);
+		TOURNAMENT_FIGHT_DURATION.put(TournamentFightType.F9X9, fightTime9x9);
+		
+		TOURNAMENT_DUELIST_ALLOWED.clear();
+		TOURNAMENT_DREADNOUGHT_ALLOWED.clear();
+		TOURNAMENT_TANKER_ALLOWED.clear();
+		TOURNAMENT_DAGGER_ALLOWED.clear();
+		TOURNAMENT_ARCHER_ALLOWED.clear();
+		TOURNAMENT_HEALER_ALLOWED.clear();
+		TOURNAMENT_ARCHMAGE_ALLOWED.clear();
+		TOURNAMENT_SOULTAKER_ALLOWED.clear();
+		TOURNAMENT_MYSTICMUSE_ALLOWED.clear();
+		TOURNAMENT_STORMSCREAMER_ALLOWED.clear();
+		TOURNAMENT_TITAN_ALLOWED.clear();
+		TOURNAMENT_DOMINATOR_ALLOWED.clear();
+		TOURNAMENT_DOOMCRYER_ALLOWED.clear();
+		// ARCHERS
+		int archer1x1 = tournament.getProperty("ArchersCountAllowed_1x1", 1);
+		int archer2x2 = tournament.getProperty("ArchersCountAllowed_2x2", 1);
+		int archer3x3 = tournament.getProperty("ArchersCountAllowed_3x3", 1);
+		int archer4x4 = tournament.getProperty("ArchersCountAllowed_4x4", 1);
+		int archer5x5 = tournament.getProperty("ArchersCountAllowed_5x5", 1);
+		int archer9x9 = tournament.getProperty("ArchersCountAllowed_9x9", 1);
+		
+		TOURNAMENT_ARCHER_ALLOWED.put(TournamentFightType.F1X1, archer1x1);
+		TOURNAMENT_ARCHER_ALLOWED.put(TournamentFightType.F2X2, archer2x2);
+		TOURNAMENT_ARCHER_ALLOWED.put(TournamentFightType.F3X3, archer3x3);
+		TOURNAMENT_ARCHER_ALLOWED.put(TournamentFightType.F4X4, archer4x4);
+		TOURNAMENT_ARCHER_ALLOWED.put(TournamentFightType.F5X5, archer5x5);
+		TOURNAMENT_ARCHER_ALLOWED.put(TournamentFightType.F9X9, archer9x9);
+		
+		// archmages
+		int archmage1X1 = tournament.getProperty("ArchmagesCountAllowed_1x1", 1);
+		int archmage2x2 = tournament.getProperty("ArchmagesCountAllowed_2x2", 1);
+		int archmage3x3 = tournament.getProperty("ArchmagesCountAllowed_3x3", 1);
+		int archmage4x4 = tournament.getProperty("ArchmagesCountAllowed_4x4", 1);
+		int archmage5x5 = tournament.getProperty("ArchmagesCountAllowed_5x5", 1);
+		int archmage9x9 = tournament.getProperty("ArchmagesCountAllowed_9x9", 1);
+		
+		TOURNAMENT_ARCHMAGE_ALLOWED.put(TournamentFightType.F1X1, archmage1X1);
+		TOURNAMENT_ARCHMAGE_ALLOWED.put(TournamentFightType.F2X2, archmage2x2);
+		TOURNAMENT_ARCHMAGE_ALLOWED.put(TournamentFightType.F3X3, archmage3x3);
+		TOURNAMENT_ARCHMAGE_ALLOWED.put(TournamentFightType.F4X4, archmage4x4);
+		TOURNAMENT_ARCHMAGE_ALLOWED.put(TournamentFightType.F5X5, archmage5x5);
+		TOURNAMENT_ARCHMAGE_ALLOWED.put(TournamentFightType.F9X9, archmage9x9);
+		
+		// DAGGERS
+		int dagger1x1 = tournament.getProperty("DaggersCountAllowed_1x1", 1);
+		int dagger2x2 = tournament.getProperty("DaggersCountAllowed_2x2", 1);
+		int dagger3x3 = tournament.getProperty("DaggersCountAllowed_3x3", 1);
+		int dagger4x4 = tournament.getProperty("DaggersCountAllowed_4x4", 1);
+		int dagger5x5 = tournament.getProperty("DaggersCountAllowed_5x5", 1);
+		int dagger9x9 = tournament.getProperty("DaggersCountAllowed_9x9", 1);
+		
+		TOURNAMENT_DAGGER_ALLOWED.put(TournamentFightType.F1X1, dagger1x1);
+		TOURNAMENT_DAGGER_ALLOWED.put(TournamentFightType.F2X2, dagger2x2);
+		TOURNAMENT_DAGGER_ALLOWED.put(TournamentFightType.F3X3, dagger3x3);
+		TOURNAMENT_DAGGER_ALLOWED.put(TournamentFightType.F4X4, dagger4x4);
+		TOURNAMENT_DAGGER_ALLOWED.put(TournamentFightType.F5X5, dagger5x5);
+		TOURNAMENT_DAGGER_ALLOWED.put(TournamentFightType.F9X9, dagger9x9);
+		
+		// DOMINATOR
+		int dominator1x1 = tournament.getProperty("DominatorsCountAllowed_1x1", 1);
+		int dominator2x2 = tournament.getProperty("DominatorsCountAllowed_2x2", 1);
+		int dominator3x3 = tournament.getProperty("DominatorsCountAllowed_3x3", 1);
+		int dominator4x4 = tournament.getProperty("DominatorsCountAllowed_4x4", 1);
+		int dominator5x5 = tournament.getProperty("DominatorsCountAllowed_5x5", 1);
+		int dominator9x9 = tournament.getProperty("DominatorsCountAllowed_9x9", 1);
+		
+		TOURNAMENT_DOMINATOR_ALLOWED.put(TournamentFightType.F1X1, dominator1x1);
+		TOURNAMENT_DOMINATOR_ALLOWED.put(TournamentFightType.F2X2, dominator2x2);
+		TOURNAMENT_DOMINATOR_ALLOWED.put(TournamentFightType.F3X3, dominator3x3);
+		TOURNAMENT_DOMINATOR_ALLOWED.put(TournamentFightType.F4X4, dominator4x4);
+		TOURNAMENT_DOMINATOR_ALLOWED.put(TournamentFightType.F5X5, dominator5x5);
+		TOURNAMENT_DOMINATOR_ALLOWED.put(TournamentFightType.F9X9, dominator9x9);
+		
+		// DOOMCRYER
+		int doomcryer1x1 = tournament.getProperty("DoomcryersCountAllowed_1x1", 1);
+		int doomcryer2x2 = tournament.getProperty("DoomcryersCountAllowed_2x2", 1);
+		int doomcryer3x3 = tournament.getProperty("DoomcryersCountAllowed_3x3", 1);
+		int doomcryer4x4 = tournament.getProperty("DoomcryersCountAllowed_4x4", 1);
+		int doomcryer5x5 = tournament.getProperty("DoomcryersCountAllowed_5x5", 1);
+		int doomcryer9x9 = tournament.getProperty("DoomcryersCountAllowed_9x9", 1);
+		
+		TOURNAMENT_DOOMCRYER_ALLOWED.put(TournamentFightType.F1X1, doomcryer1x1);
+		TOURNAMENT_DOOMCRYER_ALLOWED.put(TournamentFightType.F2X2, doomcryer2x2);
+		TOURNAMENT_DOOMCRYER_ALLOWED.put(TournamentFightType.F3X3, doomcryer3x3);
+		TOURNAMENT_DOOMCRYER_ALLOWED.put(TournamentFightType.F4X4, doomcryer4x4);
+		TOURNAMENT_DOOMCRYER_ALLOWED.put(TournamentFightType.F5X5, doomcryer5x5);
+		TOURNAMENT_DOOMCRYER_ALLOWED.put(TournamentFightType.F9X9, doomcryer9x9);
+		
+		// DREADNOUGHT
+		int dreadnought1x1 = tournament.getProperty("DreadnoughtsCountAllowed_1x1", 1);
+		int dreadnought2x2 = tournament.getProperty("DreadnoughtsCountAllowed_2x2", 1);
+		int dreadnought3x3 = tournament.getProperty("DreadnoughtsCountAllowed_3x3", 1);
+		int dreadnought4x4 = tournament.getProperty("DreadnoughtsCountAllowed_4x4", 1);
+		int dreadnought5x5 = tournament.getProperty("DreadnoughtsCountAllowed_5x5", 1);
+		int dreadnought9x9 = tournament.getProperty("DreadnoughtsCountAllowed_9x9", 1);
+		
+		TOURNAMENT_DREADNOUGHT_ALLOWED.put(TournamentFightType.F1X1, dreadnought1x1);
+		TOURNAMENT_DREADNOUGHT_ALLOWED.put(TournamentFightType.F2X2, dreadnought2x2);
+		TOURNAMENT_DREADNOUGHT_ALLOWED.put(TournamentFightType.F3X3, dreadnought3x3);
+		TOURNAMENT_DREADNOUGHT_ALLOWED.put(TournamentFightType.F4X4, dreadnought4x4);
+		TOURNAMENT_DREADNOUGHT_ALLOWED.put(TournamentFightType.F5X5, dreadnought5x5);
+		TOURNAMENT_DREADNOUGHT_ALLOWED.put(TournamentFightType.F9X9, dreadnought9x9);
+		
+		// DUELIST
+		int duelist1x1 = tournament.getProperty("DuelistsCountAllowed_1x1", 1);
+		int duelist2x2 = tournament.getProperty("DuelistsCountAllowed_2x2", 1);
+		int duelist3x3 = tournament.getProperty("DuelistsCountAllowed_3x3", 1);
+		int duelist4x4 = tournament.getProperty("DuelistsCountAllowed_4x4", 1);
+		int duelist5x5 = tournament.getProperty("DuelistsCountAllowed_5x5", 1);
+		int duelist9x9 = tournament.getProperty("DuelistsCountAllowed_9x9", 1);
+		
+		TOURNAMENT_DUELIST_ALLOWED.put(TournamentFightType.F1X1, duelist1x1);
+		TOURNAMENT_DUELIST_ALLOWED.put(TournamentFightType.F2X2, duelist2x2);
+		TOURNAMENT_DUELIST_ALLOWED.put(TournamentFightType.F3X3, duelist3x3);
+		TOURNAMENT_DUELIST_ALLOWED.put(TournamentFightType.F4X4, duelist4x4);
+		TOURNAMENT_DUELIST_ALLOWED.put(TournamentFightType.F5X5, duelist5x5);
+		TOURNAMENT_DUELIST_ALLOWED.put(TournamentFightType.F9X9, duelist9x9);
+		
+		// HEALER
+		int healer1x1 = tournament.getProperty("HealersCountAllowed_1x1", 1);
+		int healer2x2 = tournament.getProperty("HealersCountAllowed_2x2", 1);
+		int healer3x3 = tournament.getProperty("HealersCountAllowed_3x3", 1);
+		int healer4x4 = tournament.getProperty("HealersCountAllowed_4x4", 1);
+		int healer5x5 = tournament.getProperty("HealersCountAllowed_5x5", 1);
+		int healer9x9 = tournament.getProperty("HealersCountAllowed_9x9", 1);
+		
+		TOURNAMENT_HEALER_ALLOWED.put(TournamentFightType.F1X1, healer1x1);
+		TOURNAMENT_HEALER_ALLOWED.put(TournamentFightType.F2X2, healer2x2);
+		TOURNAMENT_HEALER_ALLOWED.put(TournamentFightType.F3X3, healer3x3);
+		TOURNAMENT_HEALER_ALLOWED.put(TournamentFightType.F4X4, healer4x4);
+		TOURNAMENT_HEALER_ALLOWED.put(TournamentFightType.F5X5, healer5x5);
+		TOURNAMENT_HEALER_ALLOWED.put(TournamentFightType.F9X9, healer9x9);
+		
+		// MYSTIC MUSE
+		int mysticmuse1x1 = tournament.getProperty("MysticMusesCountAllowed_1x1", 1);
+		int mysticmuse2x2 = tournament.getProperty("MysticMusesCountAllowed_2x2", 1);
+		int mysticmuse3x3 = tournament.getProperty("MysticMusesCountAllowed_3x3", 1);
+		int mysticmuse4x4 = tournament.getProperty("MysticMusesCountAllowed_4x4", 1);
+		int mysticmuse5x5 = tournament.getProperty("MysticMusesCountAllowed_5x5", 1);
+		int mysticmuse9x9 = tournament.getProperty("MysticMusesCountAllowed_9x9", 1);
+		
+		TOURNAMENT_MYSTICMUSE_ALLOWED.put(TournamentFightType.F1X1, mysticmuse1x1);
+		TOURNAMENT_MYSTICMUSE_ALLOWED.put(TournamentFightType.F2X2, mysticmuse2x2);
+		TOURNAMENT_MYSTICMUSE_ALLOWED.put(TournamentFightType.F3X3, mysticmuse3x3);
+		TOURNAMENT_MYSTICMUSE_ALLOWED.put(TournamentFightType.F4X4, mysticmuse4x4);
+		TOURNAMENT_MYSTICMUSE_ALLOWED.put(TournamentFightType.F5X5, mysticmuse5x5);
+		TOURNAMENT_MYSTICMUSE_ALLOWED.put(TournamentFightType.F9X9, mysticmuse9x9);
+		
+		// SOUL TAKER
+		int soulTaker1x1 = tournament.getProperty("SoulTakersCountAllowed_1x1", 1);
+		int soulTaker2x2 = tournament.getProperty("SoulTakersCountAllowed_2x2", 1);
+		int soulTaker3x3 = tournament.getProperty("SoulTakersCountAllowed_3x3", 1);
+		int soulTaker4x4 = tournament.getProperty("SoulTakersCountAllowed_4x4", 1);
+		int soulTaker5x5 = tournament.getProperty("SoulTakersCountAllowed_5x5", 1);
+		int soulTaker9x9 = tournament.getProperty("SoulTakersCountAllowed_9x9", 1);
+		
+		TOURNAMENT_SOULTAKER_ALLOWED.put(TournamentFightType.F1X1, soulTaker1x1);
+		TOURNAMENT_SOULTAKER_ALLOWED.put(TournamentFightType.F2X2, soulTaker2x2);
+		TOURNAMENT_SOULTAKER_ALLOWED.put(TournamentFightType.F3X3, soulTaker3x3);
+		TOURNAMENT_SOULTAKER_ALLOWED.put(TournamentFightType.F4X4, soulTaker4x4);
+		TOURNAMENT_SOULTAKER_ALLOWED.put(TournamentFightType.F5X5, soulTaker5x5);
+		TOURNAMENT_SOULTAKER_ALLOWED.put(TournamentFightType.F9X9, soulTaker9x9);
+		
+		// TITAN
+		int titan1x1 = tournament.getProperty("TitansCountAllowed_1x1", 1);
+		int titan2x2 = tournament.getProperty("TitansCountAllowed_2x2", 1);
+		int titan3x3 = tournament.getProperty("TitansCountAllowed_3x3", 1);
+		int titan4x4 = tournament.getProperty("TitansCountAllowed_4x4", 1);
+		int titan5x5 = tournament.getProperty("TitansCountAllowed_5x5", 1);
+		int titan9x9 = tournament.getProperty("TitansCountAllowed_9x9", 1);
+		
+		TOURNAMENT_TITAN_ALLOWED.put(TournamentFightType.F1X1, titan1x1);
+		TOURNAMENT_TITAN_ALLOWED.put(TournamentFightType.F2X2, titan2x2);
+		TOURNAMENT_TITAN_ALLOWED.put(TournamentFightType.F3X3, titan3x3);
+		TOURNAMENT_TITAN_ALLOWED.put(TournamentFightType.F4X4, titan4x4);
+		TOURNAMENT_TITAN_ALLOWED.put(TournamentFightType.F5X5, titan5x5);
+		TOURNAMENT_TITAN_ALLOWED.put(TournamentFightType.F9X9, titan9x9);
+		
+		// STORM SCREAMER
+		int stormScreamer1x1 = tournament.getProperty("StormScreamersCountAllowed_1x1", 1);
+		int stormScreamer2x2 = tournament.getProperty("StormScreamersCountAllowed_2x2", 1);
+		int stormScreamer3x3 = tournament.getProperty("StormScreamersCountAllowed_3x3", 1);
+		int stormScreamer4x4 = tournament.getProperty("StormScreamersCountAllowed_4x4", 1);
+		int stormScreamer5x5 = tournament.getProperty("StormScreamersCountAllowed_5x5", 1);
+		int stormScreamer9x9 = tournament.getProperty("StormScreamersCountAllowed_9x9", 1);
+		
+		TOURNAMENT_STORMSCREAMER_ALLOWED.put(TournamentFightType.F1X1, stormScreamer1x1);
+		TOURNAMENT_STORMSCREAMER_ALLOWED.put(TournamentFightType.F2X2, stormScreamer2x2);
+		TOURNAMENT_STORMSCREAMER_ALLOWED.put(TournamentFightType.F3X3, stormScreamer3x3);
+		TOURNAMENT_STORMSCREAMER_ALLOWED.put(TournamentFightType.F4X4, stormScreamer4x4);
+		TOURNAMENT_STORMSCREAMER_ALLOWED.put(TournamentFightType.F5X5, stormScreamer5x5);
+		TOURNAMENT_STORMSCREAMER_ALLOWED.put(TournamentFightType.F9X9, stormScreamer9x9);
+		
+		// TANKERS
+		int tanker1x1 = tournament.getProperty("TankersCountAllowed_1x1", 1);
+		int tanker2x2 = tournament.getProperty("TankersCountAllowed_2x2", 1);
+		int tanker3x3 = tournament.getProperty("TankersCountAllowed_3x3", 1);
+		int tanker4x4 = tournament.getProperty("TankersCountAllowed_4x4", 1);
+		int tanker5x5 = tournament.getProperty("TankersCountAllowed_5x5", 1);
+		int tanker9x9 = tournament.getProperty("TankersCountAllowed_9x9", 1);
+		
+		TOURNAMENT_TANKER_ALLOWED.put(TournamentFightType.F1X1, tanker1x1);
+		TOURNAMENT_TANKER_ALLOWED.put(TournamentFightType.F2X2, tanker2x2);
+		TOURNAMENT_TANKER_ALLOWED.put(TournamentFightType.F3X3, tanker3x3);
+		TOURNAMENT_TANKER_ALLOWED.put(TournamentFightType.F4X4, tanker4x4);
+		TOURNAMENT_TANKER_ALLOWED.put(TournamentFightType.F5X5, tanker5x5);
+		TOURNAMENT_TANKER_ALLOWED.put(TournamentFightType.F9X9, tanker9x9);
+		
+	}
+
 	/**
 	 * Loads gameserver settings.<br>
 	 * IP addresses, database, rates, feature enabled/disabled, misc.
@@ -1318,6 +1631,7 @@
 		loadServer();
 		
 		loadSpecialMods();
+		loadTournament();
 	}
 	
 	public static final void loadLoginServer()
diff --git a/aCis_gameserver/java/net/sf/l2j/commons/data/xml/IXmlReader.java b/aCis_gameserver/java/net/sf/l2j/commons/data/xml/IXmlReader.java
index 0e555e7..915484b 100644
--- a/aCis_gameserver/java/net/sf/l2j/commons/data/xml/IXmlReader.java
+++ b/aCis_gameserver/java/net/sf/l2j/commons/data/xml/IXmlReader.java
@@ -438,4 +438,18 @@
 			throw e;
 		}
 	}
+	
+	/**
+	 * This method parses the content of a NamedNodeMap and feed the given StatsSet.
+	 * @param attrs : The NamedNodeMap to parse.
+	 * @param set : The StatsSet to feed.
+	 */
+	default void parseAndFeed(NamedNodeMap attrs, StatSet set)
+	{
+		for (int i = 0; i < attrs.getLength(); i++)
+		{
+			final Node attr = attrs.item(i);
+			set.set(attr.getNodeName(), attr.getNodeValue());
+		}
+	}
 }
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/GameServer.java b/aCis_gameserver/java/net/sf/l2j/gameserver/GameServer.java
index dd3e0ce..de7798b 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/GameServer.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/GameServer.java
@@ -75,11 +75,13 @@
 import net.sf.l2j.gameserver.data.xml.WalkerRouteData;
 import net.sf.l2j.gameserver.geoengine.GeoEngine;
 import net.sf.l2j.gameserver.handler.AdminCommandHandler;
+import net.sf.l2j.gameserver.handler.BypassHandler;
 import net.sf.l2j.gameserver.handler.ChatHandler;
 import net.sf.l2j.gameserver.handler.ItemHandler;
 import net.sf.l2j.gameserver.handler.SkillHandler;
 import net.sf.l2j.gameserver.handler.TargetHandler;
 import net.sf.l2j.gameserver.handler.UserCommandHandler;
+import net.sf.l2j.gameserver.handler.VoicedCommandHandler;
 import net.sf.l2j.gameserver.idfactory.IdFactory;
 import net.sf.l2j.gameserver.model.World;
 import net.sf.l2j.gameserver.model.boat.BoatGiranTalking;
@@ -87,6 +89,8 @@
 import net.sf.l2j.gameserver.model.boat.BoatInnadrilTour;
 import net.sf.l2j.gameserver.model.boat.BoatRunePrimeval;
 import net.sf.l2j.gameserver.model.boat.BoatTalkingGludin;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.instance.InstanceManager;
 import net.sf.l2j.gameserver.model.olympiad.Olympiad;
 import net.sf.l2j.gameserver.model.olympiad.OlympiadGameManager;
 import net.sf.l2j.gameserver.network.GameClient;
@@ -262,6 +266,12 @@
 		else
 			LOGGER.info("# Auto Restart System is Disabled #");
 	
+		StringUtil.printSection("Instance Manager");
+		InstanceManager.getInstance();
+
+		StringUtil.printSection("Tournament Manager");
+		TournamentManager.getInstance();
+
 		StringUtil.printSection("Events");
 		DerbyTrackManager.getInstance();
 		LotteryManager.getInstance();
@@ -279,6 +289,8 @@
 		LOGGER.info("Loaded {} skill handlers.", SkillHandler.getInstance().size());
 		LOGGER.info("Loaded {} target handlers.", TargetHandler.getInstance().size());
 		LOGGER.info("Loaded {} user command handlers.", UserCommandHandler.getInstance().size());
+		LOGGER.info("Loaded {} bypass command handlers.", BypassHandler.getInstance().size());
+		LOGGER.info("Loaded {} user VoicedCommandHandler handlers.", VoicedCommandHandler.getInstance().size());
 		
 		StringUtil.printSection("System");
 		Runtime.getRuntime().addShutdownHook(Shutdown.getInstance());
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/enums/ZoneId.java b/aCis_gameserver/java/net/sf/l2j/gameserver/enums/ZoneId.java
index e381336..aa29e2e 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/enums/ZoneId.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/enums/ZoneId.java
@@ -21,7 +21,8 @@
 	CAST_ON_ARTIFACT(16),
 	NO_RESTART(17),
 	SCRIPT(18),
-	BOSS(19);
+	BOSS(19),
+	TOURNAMENT(20);
 	
 	private final int _id;
 	
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/enums/actors/ClassId.java b/aCis_gameserver/java/net/sf/l2j/gameserver/enums/actors/ClassId.java
index 3c7186d..c288dfb 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/enums/actors/ClassId.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/enums/actors/ClassId.java
@@ -2,6 +2,7 @@
 
 import java.util.EnumSet;
 
+import net.sf.l2j.commons.util.ArraysUtil;
 import net.sf.l2j.gameserver.model.actor.Player;
 
 /**
@@ -341,4 +342,72 @@
 		for (ClassId classId : VALUES)
 			classId.createSubclasses();
 	}
+	
+	private static final ClassId[] HEALERS =
+	{
+		ClassId.BISHOP,
+		ClassId.CARDINAL,
+		ClassId.EVAS_SAINT,
+		ClassId.ELVEN_ELDER,
+		ClassId.SHILLIEN_SAINT,
+		ClassId.SHILLIEN_ELDER
+	};
+	
+	private static final ClassId[] TANKERS =
+	{
+		ClassId.HELL_KNIGHT,
+		ClassId.DARK_AVENGER,
+		ClassId.SHILLIEN_KNIGHT,
+		ClassId.SHILLIEN_TEMPLAR,
+		ClassId.EVAS_TEMPLAR,
+		ClassId.TEMPLE_KNIGHT,
+		ClassId.BLADEDANCER,
+		ClassId.SPECTRAL_DANCER,
+		ClassId.SWORD_SINGER,
+		ClassId.SWORD_MUSE,
+		ClassId.PHOENIX_KNIGHT,
+		ClassId.PALADIN,
+	};
+	
+	private static final ClassId[] DAGGERS =
+	{
+		ClassId.ADVENTURER,
+		ClassId.TREASURE_HUNTER,
+		ClassId.GHOST_HUNTER,
+		ClassId.ABYSS_WALKER,
+		ClassId.PLAINS_WALKER,
+		ClassId.WIND_RIDER,
+		ClassId.FORTUNE_SEEKER,
+		ClassId.BOUNTY_HUNTER
+	};
+	
+	private static final ClassId[] ARCHERS =
+	{
+		ClassId.SAGGITARIUS,
+		ClassId.HAWKEYE,
+		ClassId.GHOST_SENTINEL,
+		ClassId.PHANTOM_RANGER,
+		ClassId.MOONLIGHT_SENTINEL,
+		ClassId.SILVER_RANGER
+	};
+	
+	public boolean isHealer()
+	{
+		return ArraysUtil.contains(HEALERS, this);
+	}
+	
+	public boolean isDagger()
+	{
+		return ArraysUtil.contains(DAGGERS, this);
+	}
+	
+	public boolean isTanker()
+	{
+		return ArraysUtil.contains(TANKERS, this);
+	}
+	
+	public boolean isArcher()
+	{
+		return ArraysUtil.contains(ARCHERS, this);
+	}
 }
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/geoengine/geodata/IGeoObject.java b/aCis_gameserver/java/net/sf/l2j/gameserver/geoengine/geodata/IGeoObject.java
index 379e708..0b7fa40 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/geoengine/geodata/IGeoObject.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/geoengine/geodata/IGeoObject.java
@@ -31,4 +31,5 @@
 	 * @return byte[][] : {@link IGeoObject} data.
 	 */
 	public byte[][] getObjectGeoData();
+	public int getInstanceID();
 }
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/handler/AdminCommandHandler.java b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/AdminCommandHandler.java
index 54d42b8..4ebc3e3 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/handler/AdminCommandHandler.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/AdminCommandHandler.java
@@ -16,6 +16,7 @@
 import net.sf.l2j.gameserver.handler.admincommandhandlers.AdminGeoEngine;
 import net.sf.l2j.gameserver.handler.admincommandhandlers.AdminGiran;
 import net.sf.l2j.gameserver.handler.admincommandhandlers.AdminInfo;
+import net.sf.l2j.gameserver.handler.admincommandhandlers.AdminInstance;
 import net.sf.l2j.gameserver.handler.admincommandhandlers.AdminItem;
 import net.sf.l2j.gameserver.handler.admincommandhandlers.AdminKnownlist;
 import net.sf.l2j.gameserver.handler.admincommandhandlers.AdminMaintenance;
@@ -77,9 +78,10 @@
 		registerHandler(new AdminZone());
 
 		registerHandler(new AdminGiran());
-}
+		registerHandler(new AdminInstance());
+	}
 	
-	private void registerHandler(IAdminCommandHandler handler)
+	public void registerHandler(IAdminCommandHandler handler)
 	{
 		for (String id : handler.getAdminCommandList())
 			_entries.put(id.hashCode(), handler);
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/handler/BypassHandler.java b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/BypassHandler.java
new file mode 100644
index 0000000..1187ecb
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/BypassHandler.java
@@ -0,0 +1,56 @@
+package net.sf.l2j.gameserver.handler;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.logging.Logger;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.model.entity.Tournament.ByPasses.TournamentBypasses;
+
+/**
+ * @author Anarchy
+ */
+public class BypassHandler
+{
+	private static Logger _log = Logger.getLogger(BypassHandler.class.getName());
+	private final Map<Integer, IBypassHandler> _datatable = new HashMap<>();
+	
+	public static BypassHandler getInstance()
+	{
+		return SingletonHolder._instance;
+	}
+	
+	private BypassHandler()
+	{
+		registerBypassHandler(new TournamentBypasses());		
+	}
+	
+	public void registerBypassHandler(IBypassHandler handler)
+	{
+		String[] ids = handler.getBypassHandlersList();
+		for (int i = 0; i < ids.length; i++)
+		{
+			_datatable.put(ids[i].hashCode(), handler);
+		}
+	}
+	
+	public IBypassHandler getBypassHandler(String bypass)
+	{
+		String command = bypass;
+		if (bypass.indexOf(" ") != -1)
+			command = bypass.substring(0, bypass.indexOf(" "));
+		if (Config.DEBUG)
+			_log.fine("getting handler for command: " + command + " -> " + (_datatable.get(command.hashCode()) != null));
+		return _datatable.get(command.hashCode());
+	}
+	
+	public int size()
+	{
+		return _datatable.size();
+	}
+	
+	private static class SingletonHolder
+	{
+		protected static final BypassHandler _instance = new BypassHandler();
+	}
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/handler/IBypassHandler.java b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/IBypassHandler.java
new file mode 100644
index 0000000..b5a95b8
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/IBypassHandler.java
@@ -0,0 +1,13 @@
+package net.sf.l2j.gameserver.handler;
+
+import net.sf.l2j.gameserver.model.actor.Player;
+
+/**
+ * @author Anarchy
+ */
+public interface IBypassHandler
+{
+	public boolean handleBypass(String bypass, Player activeChar);
+	
+	public String[] getBypassHandlersList();
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/handler/IVoicedCommandHandler.java b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/IVoicedCommandHandler.java
new file mode 100644
index 0000000..4bf2b35
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/IVoicedCommandHandler.java
@@ -0,0 +1,10 @@
+package net.sf.l2j.gameserver.handler;
+
+import net.sf.l2j.gameserver.model.actor.Player;
+
+public interface IVoicedCommandHandler
+{
+	public boolean useVoicedCommand(String command, Player activeChar, String target);
+	
+	public String[] getVoicedCommandList();
+}
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/handler/VoicedCommandHandler.java b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/VoicedCommandHandler.java
new file mode 100644
index 0000000..baa77a3
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/VoicedCommandHandler.java
@@ -0,0 +1,65 @@
+package net.sf.l2j.gameserver.handler;
+
+import java.util.HashMap;
+import java.util.Map;
+import java.util.logging.Logger;
+
+import net.sf.l2j.gameserver.GameServer;
+
+public class VoicedCommandHandler
+{
+	private static Logger LOGGER = Logger.getLogger(GameServer.class.getName());
+	
+	private static VoicedCommandHandler _instance;
+	
+	private final Map<String, IVoicedCommandHandler> _datatable;
+	
+	public static VoicedCommandHandler getInstance()
+	{
+		if (_instance == null)
+		{
+			_instance = new VoicedCommandHandler();
+		}
+		
+		return _instance;
+	}
+	
+	private VoicedCommandHandler()
+	{
+		_datatable = new HashMap<>();
+
+		//registerVoicedCommandHandler(new Shiff_Mod());
+		
+		LOGGER.info("VoicedCommandHandler: Loaded " + _datatable.size() + " handlers.");
+	}
+	
+	public void registerHandler(final IVoicedCommandHandler handler)
+	{
+		String[] ids = handler.getVoicedCommandList();
+		
+		for (final String id : ids)
+		{
+			_datatable.put(id, handler);
+		}
+		
+		ids = null;
+	}
+	
+	public IVoicedCommandHandler getVoicedCommandHandler(final String voicedCommand)
+	{
+		String command = voicedCommand;
+		
+		if (voicedCommand.indexOf(" ") != -1)
+		{
+			command = voicedCommand.substring(0, voicedCommand.indexOf(" "));
+		}
+		return _datatable.get(command);
+	}
+	/**
+	 * @return
+	 */
+	public int size()
+	{
+		return _datatable.size();
+	}
+}
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/handler/admincommandhandlers/AdminInstance.java b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/admincommandhandlers/AdminInstance.java
new file mode 100644
index 0000000..e21ce7b
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/admincommandhandlers/AdminInstance.java
@@ -0,0 +1,60 @@
+package net.sf.l2j.gameserver.handler.admincommandhandlers;
+
+import java.util.StringTokenizer;
+
+import net.sf.l2j.gameserver.handler.IAdminCommandHandler;
+import net.sf.l2j.gameserver.model.World;
+import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.instance.InstanceManager;
+
+/**
+ * @author Rouxy
+ */
+public class AdminInstance implements IAdminCommandHandler
+{
+	
+	@Override
+	public void useAdminCommand(String command, Player activeChar)
+	{
+		if (command.startsWith("admin_getinstance"))
+		{
+			StringTokenizer st = new StringTokenizer(command, " ");
+			st.nextToken(); // skip command
+			
+			if (!st.hasMoreTokens())
+			{
+				activeChar.sendMessage("Write the name.");
+				return;
+			}
+			
+			String target_name = st.nextToken();
+			Player player = World.getInstance().getPlayer(target_name);
+			if (player == null)
+			{
+				activeChar.sendMessage("Player is offline");
+				return;
+			}
+			
+			activeChar.setInstance(player.getInstance(), false);
+			activeChar.sendMessage("You are with the same instance of player " + target_name);
+		}
+		else if (command.startsWith("admin_resetmyinstance"))
+		{
+			activeChar.setInstance(InstanceManager.getInstance().getInstance(0), false);
+			activeChar.sendMessage("Your instance is now default");
+		}
+		
+	}
+	
+	@Override
+	public String[] getAdminCommandList()
+	{
+		
+		return new String[]
+		{
+			"admin_getinstance",
+			"admin_resetmyinstance"
+		};
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/handler/admincommandhandlers/AdminReload.java b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/admincommandhandlers/AdminReload.java
index 5f11f94..1d4dab0 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/handler/admincommandhandlers/AdminReload.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/admincommandhandlers/AdminReload.java
@@ -21,6 +21,7 @@
 import net.sf.l2j.gameserver.data.xml.WalkerRouteData;
 import net.sf.l2j.gameserver.handler.IAdminCommandHandler;
 import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.Data.TournamentArenaParser;
 
 public class AdminReload implements IAdminCommandHandler
 {
@@ -45,6 +46,11 @@
 					AdminData.getInstance().reload();
 					player.sendMessage("Admin data has been reloaded.");
 				}
+				else if (type.startsWith("tournamentarena"))
+				{
+					TournamentArenaParser.getInstance().reload();
+					player.sendMessage("The content of Tournament arenas.xml has been reloaded.");
+				}
 				else if (type.startsWith("announcement"))
 				{
 					AnnouncementData.getInstance().reload();
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/handler/chathandlers/ChatAll.java b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/chathandlers/ChatAll.java
index a707ce5..e81b8bd 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/handler/chathandlers/ChatAll.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/handler/chathandlers/ChatAll.java
@@ -1,8 +1,12 @@
 package net.sf.l2j.gameserver.handler.chathandlers;
 
+import java.util.StringTokenizer;
+
 import net.sf.l2j.gameserver.enums.FloodProtector;
 import net.sf.l2j.gameserver.enums.SayType;
 import net.sf.l2j.gameserver.handler.IChatHandler;
+import net.sf.l2j.gameserver.handler.IVoicedCommandHandler;
+import net.sf.l2j.gameserver.handler.VoicedCommandHandler;
 import net.sf.l2j.gameserver.model.actor.Player;
 import net.sf.l2j.gameserver.network.serverpackets.CreatureSay;
 
@@ -18,12 +22,42 @@
 	{
 		if (!player.getClient().performAction(FloodProtector.GLOBAL_CHAT))
 			return;
-		
-		final CreatureSay cs = new CreatureSay(player, type, text);
-		for (Player knownPlayer : player.getKnownTypeInRadius(Player.class, 1250))
-			knownPlayer.sendPacket(cs);
-		
-		player.sendPacket(cs);
+
+		boolean vcd_used = false;
+		if (text.startsWith("."))
+		{
+		    StringTokenizer st = new StringTokenizer(text);
+		    IVoicedCommandHandler vch;
+		    String command = "";
+		    if (st.countTokens() > 1)
+	    {
+		        command = st.nextToken().substring(1);
+		        target = text.substring(command.length() + 2);
+		        vch = VoicedCommandHandler.getInstance().getVoicedCommandHandler(command);
+		    }
+	    else
+		    {
+		        command = text.substring(1);
+		        vch = VoicedCommandHandler.getInstance().getVoicedCommandHandler(command);
+		    }
+		            
+		    if (vch != null)
+		    {
+		        vch.useVoicedCommand(command, player, text);
+		        vcd_used = true;
+		        
+		    }
+		}
+
+		if (!vcd_used)
+		{
+			final CreatureSay cs = new CreatureSay(player, type, text);
+			for (Player knownPlayer : player.getKnownTypeInRadius(Player.class, 1250))
+				knownPlayer.sendPacket(cs);
+			
+			player.sendPacket(cs);
+			
+		}
 	}
 	
 	@Override
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/WorldObject.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/WorldObject.java
index 491d925..865bf2c 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/model/WorldObject.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/WorldObject.java
@@ -14,6 +14,9 @@
 import net.sf.l2j.gameserver.model.actor.Creature;
 import net.sf.l2j.gameserver.model.actor.Playable;
 import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.actor.instance.Fence;
+import net.sf.l2j.gameserver.model.entity.instance.Instance;
+import net.sf.l2j.gameserver.model.entity.instance.InstanceManager;
 import net.sf.l2j.gameserver.model.location.Location;
 import net.sf.l2j.gameserver.model.location.SpawnLocation;
 import net.sf.l2j.gameserver.model.zone.type.subtype.ZoneType;
@@ -370,6 +373,12 @@
 			}
 		}
 		
+		for (WorldObject object : getDifferentInstanceObjects())
+		{
+			object.removeKnownObject(this);
+			removeKnownObject(object);
+		}
+		
 		// For every new surrounding area NOT SHARED with old surrounding areas.
 		for (WorldRegion region : newAreas)
 		{
@@ -382,7 +391,8 @@
 				// Update all objects.
 				for (WorldObject obj : region.getObjects())
 				{
-					if (obj == this)
+//					if (obj == this)
+					if (obj == this || obj.getInstance().getId() != getInstance().getId())
 						continue;
 					
 					obj.addKnownObject(this);
@@ -465,6 +475,9 @@
 				if (obj == this || !type.isAssignableFrom(obj.getClass()))
 					continue;
 				
+				if (obj.getInstance().getId() != getInstance().getId() && !(obj instanceof Fence))
+					continue;
+
 				result.add((A) obj);
 			}
 		}
@@ -495,6 +508,9 @@
 				if (obj == this || !type.isAssignableFrom(obj.getClass()) || !predicate.test((A) obj))
 					continue;
 				
+				if (obj.getInstance().getId() != getInstance().getId() && !(obj instanceof Fence))
+					continue;
+
 				result.add((A) obj);
 			}
 		}
@@ -741,4 +757,46 @@
 	{
 		
 	}
+	
+	// Rouxy: Instance
+	private Instance _instance = InstanceManager.getInstance().getInstance(0);
+	
+	public void setInstance(Instance instance, boolean silent)
+	{
+		_instance = instance;
+		
+		if (!silent)
+		{
+			decayMe();
+			spawnMe();
+		}
+	}
+	
+	public Instance getInstance()
+	{
+		return _instance;
+	}
+	
+	private final List<WorldObject> getDifferentInstanceObjects()
+	{
+		final WorldRegion region = _region;
+		if (region == null)
+			return Collections.emptyList();
+		
+		final List<WorldObject> result = new ArrayList<>();
+		
+		for (WorldRegion reg : region.getSurroundingRegions())
+		{
+			for (WorldObject obj : reg.getObjects())
+			{
+				if (obj == this || obj.getInstance().getId() == getInstance().getId() || obj instanceof Fence)
+					continue;
+				
+				result.add(obj);
+			}
+		}
+		
+		return result;
+	}
+
 }
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/Player.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/Player.java
index f22e924..f02bcfb 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/Player.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/Player.java
@@ -57,6 +57,7 @@
 import net.sf.l2j.gameserver.enums.MessageType;
 import net.sf.l2j.gameserver.enums.Paperdoll;
 import net.sf.l2j.gameserver.enums.PunishmentType;
+import net.sf.l2j.gameserver.enums.SayType;
 import net.sf.l2j.gameserver.enums.ShortcutType;
 import net.sf.l2j.gameserver.enums.SpawnType;
 import net.sf.l2j.gameserver.enums.StatusType;
@@ -122,6 +123,9 @@
 import net.sf.l2j.gameserver.model.craft.ManufactureList;
 import net.sf.l2j.gameserver.model.entity.Castle;
 import net.sf.l2j.gameserver.model.entity.Duel.DuelState;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
 import net.sf.l2j.gameserver.model.group.CommandChannel;
 import net.sf.l2j.gameserver.model.group.Party;
 import net.sf.l2j.gameserver.model.group.PartyMatchRoom;
@@ -156,6 +160,7 @@
 import net.sf.l2j.gameserver.network.serverpackets.ChangeWaitType;
 import net.sf.l2j.gameserver.network.serverpackets.CharInfo;
 import net.sf.l2j.gameserver.network.serverpackets.ConfirmDlg;
+import net.sf.l2j.gameserver.network.serverpackets.CreatureSay;
 import net.sf.l2j.gameserver.network.serverpackets.DeleteObject;
 import net.sf.l2j.gameserver.network.serverpackets.EtcStatusUpdate;
 import net.sf.l2j.gameserver.network.serverpackets.ExAutoSoulShot;
@@ -222,6 +227,9 @@
 import net.sf.l2j.gameserver.taskmanager.PvpFlagTaskManager;
 import net.sf.l2j.gameserver.taskmanager.ShadowItemTaskManager;
 import net.sf.l2j.gameserver.taskmanager.WaterTaskManager;
+import net.sf.l2j.util.Mysql;
+import net.sf.l2j.util.PlayerVar;
+import net.sf.l2j.util.PlayerVariables;
 
 /**
  * This class represents a player in the world.<br>
@@ -2114,7 +2122,8 @@
 			
 			return null;
 		}
-		
+			
+		item.setInstance(getInstance(), true); // True because Drop me will spawn it
 		item.dropMe(this, x, y, z);
 		
 		// Send inventory update packet
@@ -2701,6 +2710,7 @@
 		{
 			final Player pk = killer.getActingPlayer();
 			
+			TournamentManager.getInstance().onKill(killer, this);
 			// Clear resurrect xp calculation
 			setExpBeforeDeath(0);
 			
@@ -4341,6 +4351,9 @@
 						player.getStatus().stopHpMpRegeneration();
 					}
 					
+					PlayerVariables.loadVariables(player);
+					TournamentManager.getInstance().onPlayerEnter(player);
+
 					// Restore pet if it exists in the world.
 					final Pet pet = World.getInstance().getPet(player.getObjectId());
 					if (pet != null)
@@ -6425,6 +6438,8 @@
 	{
 		super.deleteMe();
 		
+		TournamentManager.getInstance().storeTournamentData(this);
+		
 		cleanup();
 		store();
 	}
@@ -6807,6 +6822,10 @@
 		
 		if (isInOlympiadMode() && target instanceof Player && ((Player) target).isInOlympiadMode() && ((Player) target).getOlympiadGameId() == getOlympiadGameId())
 			OlympiadGameManager.getInstance().notifyCompetitorDamage(this, damage);
+		
+		if (isInTournamentMatch() && target instanceof Player && ((Player) target).isInTournamentMatch() && ((Player) target).getTournamentFightId() == getTournamentFightId())
+			addTournamentMatchDamage(damage);
+
 	}
 	
 	public void checkItemRestriction()
@@ -7379,4 +7398,468 @@
 		
 		return gms;
 	}
+	
+	// Rouxy: Daily Reward
+	/**
+	 * @return the nextRewardTime
+	 */
+	public long getNextRewardTime()
+	{
+		return nextRewardTime;
+	}
+	
+	/**
+	 * @param nextRewardTime the nextRewardTime to set
+	 */
+	public void setNextRewardTime(long nextRewardTime)
+	{
+		this.nextRewardTime = nextRewardTime;
+	}
+	
+	private long nextRewardTime;
+	
+	// Rouxy: Tournament
+	
+	private boolean tournamentTeamBeingInvited;
+	private int tournamentFightId;
+	private TournamentFightType tournamentFightType = TournamentFightType.NONE;
+	private boolean inTournamentMatch;
+	private int lastX;
+	private int lastY;
+	private int lastZ;
+	private int tournamentPoints;
+	private int tournamentMatchDamage;
+	private Map<TournamentFightType, Integer> tournamentKills = new HashMap<>();
+	private Map<TournamentFightType, Integer> tournamentVictories = new HashMap<>();
+	private Map<TournamentFightType, Integer> tournamentDefeats = new HashMap<>();
+	private Map<TournamentFightType, Integer> tournamentTies = new HashMap<>();
+	private Map<TournamentFightType, Integer> tournamentDamage = new HashMap<>();
+	
+	public int getTournamentTotalDamage()
+	{
+		int count = 0;
+		for (Map.Entry<TournamentFightType, Integer> entry : tournamentDamage.entrySet())
+		{
+			count += entry.getValue();
+		}
+		return count;
+	}
+	
+	public int getTournamentTotalDamage(TournamentFightType type)
+	{
+		return tournamentDamage.get(type);
+	}
+	
+	public int getTotalVictories()
+	{
+		int count = 0;
+		for (Map.Entry<TournamentFightType, Integer> entry : tournamentVictories.entrySet())
+		{
+			count += entry.getValue();
+		}
+		return count;
+	}
+	
+	public int getTotalDefeats()
+	{
+		int count = 0;
+		for (Map.Entry<TournamentFightType, Integer> entry : tournamentDefeats.entrySet())
+		{
+			count += entry.getValue();
+		}
+		return count;
+	}
+	
+	public int getTotalTies()
+	{
+		int count = 0;
+		for (Map.Entry<TournamentFightType, Integer> entry : tournamentTies.entrySet())
+		{
+			count += entry.getValue();
+		}
+		return count;
+	}
+	
+	/**
+	 * @return Total of fights done by player
+	 */
+	public int getTotalTournamentFightsDone()
+	{
+		return getTournamentFightsDone(TournamentFightType.F1X1) + getTournamentFightsDone(TournamentFightType.F2X2) + getTournamentFightsDone(TournamentFightType.F3X3) + getTournamentFightsDone(TournamentFightType.F4X4) + getTournamentFightsDone(TournamentFightType.F5X5) + getTournamentFightsDone(TournamentFightType.F9X9);
+	}
+	
+	/**
+	 * @param type
+	 * @return Total of fights of type done by player
+	 */
+	public int getTournamentFightsDone(TournamentFightType type)
+	{
+		return tournamentVictories.get(type) + tournamentDefeats.get(type) + tournamentTies.get(type);
+	}
+	
+	/**
+	 * @return if player is in a registered team o tournament
+	 */
+	public boolean isInTournamentMode()
+	{
+		return TournamentManager.getInstance().isInTournamentMode(this);
+	}
+	
+	public TournamentTeam getTournamentTeam()
+	{
+		return tournamentTeam;
+	}
+	
+	public void setTournamentTeam(TournamentTeam tournamentTeam)
+	{
+		this.tournamentTeam = tournamentTeam;
+	}
+	
+	private TournamentTeam tournamentTeam;
+	
+	public boolean isInTournamentTeam()
+	{
+		return getTournamentTeam() != null;
+	}
+	
+	/**
+	 * @return if player received a invitation to a tour team
+	 */
+	public boolean isTournamentTeamBeingInvited()
+	{
+		return tournamentTeamBeingInvited;
+	}
+	
+	public void setTournamentTeamBeingInvited(boolean tournamentTeamBeingInvited)
+	{
+		this.tournamentTeamBeingInvited = tournamentTeamBeingInvited;
+	}
+	
+	public int getTournamentFightId()
+	{
+		return tournamentFightId;
+	}
+	
+	public void setTournamentFightId(int tournamentFightId)
+	{
+		this.tournamentFightId = tournamentFightId;
+	}
+	
+	public TournamentFightType getTournamentFightType()
+	{
+		return tournamentFightType;
+	}
+	
+	public void setTournamentFightType(TournamentFightType tournamentFightType)
+	{
+		this.tournamentFightType = tournamentFightType;
+	}
+	
+	/**
+	 * @return the inTournamentMatch
+	 */
+	public boolean isInTournamentMatch()
+	{
+		return inTournamentMatch;
+	}
+	
+	/**
+	 * @param inTournamentMatch the inTournamentMatch to set
+	 */
+	public void setInTournamentMatch(boolean inTournamentMatch)
+	{
+		this.inTournamentMatch = inTournamentMatch;
+	}
+	
+	/**
+	 * @return the lastX
+	 */
+	public int getLastX()
+	{
+		return lastX;
+	}
+	
+	/**
+	 * @param lastX the lastX to set
+	 */
+	public void setLastX(int lastX)
+	{
+		this.lastX = lastX;
+	}
+	
+	/**
+	 * @return the lastY
+	 */
+	public int getLastY()
+	{
+		return lastY;
+	}
+	
+	/**
+	 * @param lastY the lastY to set
+	 */
+	public void setLastY(int lastY)
+	{
+		this.lastY = lastY;
+	}
+	
+	/**
+	 * @return the lastZ
+	 */
+	public int getLastZ()
+	{
+		return lastZ;
+	}
+	
+	/**
+	 * @param lastZ the lastZ to set
+	 */
+	public void setLastZ(int lastZ)
+	{
+		this.lastZ = lastZ;
+	}
+	
+	/**
+	 * @return the tournamentMatchDamage
+	 */
+	public int getTournamentMatchDamage()
+	{
+		return tournamentMatchDamage;
+	}
+	
+	public void addTournamentMatchDamage(int damage)
+	{
+		tournamentMatchDamage += damage;
+	}
+	
+	/**
+	 * @param tournamentMatchDamage the tournamentMatchDamage to set
+	 */
+	public void setTournamentMatchDamage(int tournamentMatchDamage)
+	{
+		this.tournamentMatchDamage = tournamentMatchDamage;
+	}
+	
+	/**
+	 * @return the tournamentKills
+	 */
+	public Map<TournamentFightType, Integer> getTournamentKills()
+	{
+		return tournamentKills;
+	}
+	
+	/**
+	 * @param tournamentKills the tournamentKills to set
+	 */
+	public void setTournamentKills(Map<TournamentFightType, Integer> tournamentKills)
+	{
+		this.tournamentKills = tournamentKills;
+	}
+	
+	public void addTournamentTie(TournamentFightType type)
+	{
+		increment(tournamentTies, type);
+	}
+	
+	public void addTournamentDefeat(TournamentFightType type)
+	{
+		increment(tournamentDefeats, type);
+	}
+	
+	public void addTournamentVictory(TournamentFightType type)
+	{
+		increment(tournamentVictories, type);
+	}
+	
+	public void addTournamentKill(TournamentFightType type)
+	{
+		increment(tournamentKills, type);
+	}
+	
+	public static <K> void increment(Map<K, Integer> map, K key)
+	{
+		map.merge(key, 1, Integer::sum);
+		
+	}
+	
+	public void addTournamentDamage(TournamentFightType type, int damage)
+	{
+		increment(tournamentDamage, type, damage);
+	}
+	
+	public static <K> void increment(Map<K, Integer> map, K key, int toIncrement)
+	{
+		
+		int val = map.get(key);
+		map.put(key, val + toIncrement);
+	}
+	
+	/**
+	 * @return all kills of plaer in tournament
+	 */
+	public int getTotalTournamentKills()
+	{
+		int kills = 0;
+		for (Map.Entry<TournamentFightType, Integer> entry : tournamentKills.entrySet())
+		{
+			kills += entry.getValue();
+		}
+		return kills;
+	}
+	
+	/**
+	 * @return the tournamentVictories
+	 */
+	public Map<TournamentFightType, Integer> getTournamentVictories()
+	{
+		return tournamentVictories;
+	}
+	
+	/**
+	 * @param tournamentVictories the tournamentVictories to set
+	 */
+	public void setTournamentVictories(Map<TournamentFightType, Integer> tournamentVictories)
+	{
+		this.tournamentVictories = tournamentVictories;
+	}
+	
+	/**
+	 * @return the tournamentDefeats
+	 */
+	public Map<TournamentFightType, Integer> getTournamentDefeats()
+	{
+		return tournamentDefeats;
+	}
+	
+	/**
+	 * @param tournamentDefeats the tournamentDefeats to set
+	 */
+	public void setTournamentDefeats(Map<TournamentFightType, Integer> tournamentDefeats)
+	{
+		this.tournamentDefeats = tournamentDefeats;
+	}
+	
+	/**
+	 * @return the tournamentTies
+	 */
+	public Map<TournamentFightType, Integer> getTournamentTies()
+	{
+		return tournamentTies;
+	}
+	
+	/**
+	 * @param tournamentTies the tournamentTies to set
+	 */
+	public void setTournamentTies(Map<TournamentFightType, Integer> tournamentTies)
+	{
+		this.tournamentTies = tournamentTies;
+	}
+	
+	public void storeTournament()
+	{
+		
+	}
+	
+	/**
+	 * @return the tournamentDamage
+	 */
+	public Map<TournamentFightType, Integer> getTournamentDamage()
+	{
+		return tournamentDamage;
+	}
+	
+	/**
+	 * @param tournamentDamage the tournamentDamage to set
+	 */
+	public void setTournamentDamage(Map<TournamentFightType, Integer> tournamentDamage)
+	{
+		this.tournamentDamage = tournamentDamage;
+	}
+	
+	/**
+	 * @return the tournamentPoints
+	 */
+	public int getTournamentPoints()
+	{
+		return tournamentPoints;
+	}
+	
+	/**
+	 * @param tournamentPoints the tournamentPoints to set
+	 */
+	public void setTournamentPoints(int tournamentPoints)
+	{
+		this.tournamentPoints = tournamentPoints;
+	}
+	
+	/**
+	 * @return the tournamentTeamRequesterId
+	 */
+	public int getTournamentTeamRequesterId()
+	{
+		return tournamentTeamRequesterId;
+	}
+	
+	/**
+	 * @param tournamentTeamRequesterId the tournamentTeamRequesterId to set
+	 */
+	public void setTournamentTeamRequesterId(int tournamentTeamRequesterId)
+	{
+		this.tournamentTeamRequesterId = tournamentTeamRequesterId;
+	}
+	
+	private int tournamentTeamRequesterId;
+
+	// player variables
+	private final Map<String, PlayerVar> vars = new ConcurrentHashMap<>();
+	
+	/**
+	 * @return player memos.
+	 */
+	public Map<String, PlayerVar> getVariables()
+	{
+		return vars;
+	}
+	
+	public void deleteTempItem(int itemObjectID)
+	{
+		boolean destroyed = false;
+		if (getInventory().getItemByObjectId(itemObjectID) != null)
+		{
+			sendMessage("Your " + ItemData.getInstance().getTemplate(getInventory().getItemByObjectId(itemObjectID).getItemId()).getName() + " has expired.");
+			destroyItem("tempItemDestroy", itemObjectID, 1, this, true);
+			getInventory().updateDatabase();
+			sendPacket(new ItemList(this, true));
+			
+			destroyed = true;
+		}
+		
+		if (!destroyed)
+		{
+			Connection con = null;
+			PreparedStatement statement = null;
+			ResultSet rset = null;
+			try
+			{
+				con = ConnectionPool.getConnection();
+				statement = con.prepareStatement("DELETE FROM items WHERE object_id=?");
+				statement.setInt(1, itemObjectID);
+				statement.execute();
+			}
+			catch (Exception e)
+			{
+				e.printStackTrace();
+			}
+			finally
+			{
+				Mysql.closeQuietly(con, statement, rset);
+			}
+		}
+	}
+
+	public void sendChatMessage(int objectId, SayType messageType, String charName, String text)
+	{
+		sendPacket(new CreatureSay(objectId, messageType, charName, text));
+	}
+
 }
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/cast/PlayableCast.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/cast/PlayableCast.java
index 5e2ae8d..8a0d9c9 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/cast/PlayableCast.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/cast/PlayableCast.java
@@ -1,5 +1,6 @@
 package net.sf.l2j.gameserver.model.actor.cast;
 
+import net.sf.l2j.Config;
 import net.sf.l2j.gameserver.enums.skills.SkillType;
 import net.sf.l2j.gameserver.model.actor.Creature;
 import net.sf.l2j.gameserver.model.actor.Playable;
@@ -70,6 +71,15 @@
 		if (!skill.checkCondition(_actor, target, false))
 			return false;
 		
+		if (_actor.getActingPlayer().isInTournamentMatch())
+		{
+			if (Config.TOURNAMENT_RESTRICTED_SKILL_LIST.contains(skill.getId()))
+			{
+				_actor.sendMessage("You can't use this skill in Tournament.");
+				return false;
+			}
+		}
+
 		if (_actor.getActingPlayer().isInOlympiadMode() && (skill.isHeroSkill() || skill.getSkillType() == SkillType.RESURRECT))
 		{
 			_actor.sendPacket(SystemMessage.getSystemMessage(SystemMessageId.THIS_SKILL_IS_NOT_AVAILABLE_FOR_THE_OLYMPIAD_EVENT));
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Door.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Door.java
index 49f9f79..206cc26 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Door.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Door.java
@@ -383,4 +383,13 @@
 	{
 		return _clanHall;
 	}
+	
+	@Override
+	public int getInstanceID()
+	{
+		if (getDoorId() == 17100001 || getDoorId() == 17100002 || getDoorId() == 17100101 || getDoorId() == 17100102 || getDoorId() == 17100201 || getDoorId() == 17100202 || getDoorId() == 17100301 || getDoorId() == 17100302)
+			return 2140000000;
+		
+		return getInstance().getId();
+	}
 }
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Fence.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Fence.java
index cd75ae9..9a306b4 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Fence.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Fence.java
@@ -142,4 +142,11 @@
 			player.sendPacket(new ExColosseumFenceInfo(getObjectId(), _fence));
 		}
 	}
+
+	@Override
+	public int getInstanceID()
+	{
+		
+		return getInstance().getId();
+	}
 }
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Monster.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Monster.java
index 51afb41..8e6a0e4 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Monster.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/Monster.java
@@ -940,6 +940,9 @@
 			// Create the ItemInstance and add it in the world as a visible object.
 			final ItemInstance item = ItemInstance.create(holder.getId(), holder.getValue(), player, this);
 			item.setDropProtection(player.getObjectId(), isRaidBoss());
+			
+			item.setInstance(getInstance(), false);
+			
 			item.dropMe(this, 70);
 			
 			// If stackable, end loop as entire count is included in 1 instance of item.
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/TournamentNpc.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/TournamentNpc.java
new file mode 100644
index 0000000..3fcdbe7
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/actor/instance/TournamentNpc.java
@@ -0,0 +1,38 @@
+package net.sf.l2j.gameserver.model.actor.instance;
+
+import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.actor.template.NpcTemplate;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+
+/**
+ * @author Rouxy
+ */
+public class TournamentNpc extends Folk
+{
+	public TournamentNpc(final int objectId, final NpcTemplate template)
+	{
+		super(objectId, template);
+	}
+	
+	@Override
+	public void showChatWindow(Player player)
+	{
+		TournamentManager.getInstance().showHtml(player, "main", TournamentFightType.NONE);
+	}
+	
+	@Override
+	public String getHtmlPath(final int npcId, final int val)
+	{
+		String pom = "";
+		if (val == 0)
+		{
+			pom = "" + npcId;
+		}
+		else
+		{
+			pom = npcId + "-" + val;
+		}
+		return "data/html/mods/tournament/" + pom + ".htm";
+	}
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/ByPasses/TournamentBypasses.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/ByPasses/TournamentBypasses.java
new file mode 100644
index 0000000..ec9d1c1
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/ByPasses/TournamentBypasses.java
@@ -0,0 +1,443 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.ByPasses;
+
+import java.util.StringTokenizer;
+
+import net.sf.l2j.gameserver.data.sql.PlayerInfoTable;
+import net.sf.l2j.gameserver.handler.IBypassHandler;
+import net.sf.l2j.gameserver.model.World;
+import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.matches.TournamentMatch1x1;
+import net.sf.l2j.gameserver.model.entity.Tournament.matches.TournamentMatch2x2;
+import net.sf.l2j.gameserver.model.entity.Tournament.matches.TournamentMatch3x3;
+import net.sf.l2j.gameserver.model.entity.Tournament.matches.TournamentMatch4x4;
+import net.sf.l2j.gameserver.model.entity.Tournament.matches.TournamentMatch5x5;
+import net.sf.l2j.gameserver.model.entity.Tournament.matches.TournamentMatch9x9;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+
+public class TournamentBypasses implements IBypassHandler
+{
+	
+	@Override
+	public boolean handleBypass(String bypass, Player player)
+	{
+		StringTokenizer st = new StringTokenizer(bypass, " ");
+		st.nextToken();
+		TournamentTeam team = player.getTournamentTeam();
+		
+		if (bypass.startsWith("bp_tournamentTeamInfo"))
+		{
+			if (team != null)
+			{
+				TournamentManager.getInstance().showHtml(player, "createTeam", TournamentFightType.F2X2);
+			}
+			else
+			{
+				player.sendMessage("First you must create a new Tournament Team.");
+			}
+		}
+		if (bypass.startsWith("bp_leaveTournamentTeam"))
+		{
+			if (team != null)
+			{
+				team.removeMember(player);
+			}
+			else
+			{
+				player.sendMessage("You haven't a Team.");
+			}
+		}
+		if (bypass.startsWith("bp_registerTournament1x1"))
+		{
+			TournamentManager.getInstance().showHtml(player, "fights/F1X1", TournamentFightType.F1X1);
+			if (!TournamentManager.getInstance().isRunning())
+			{
+				player.sendMessage("Tournament isn't Running!");
+				return false;
+			}
+			if (!player.isInTournamentTeam())
+			{
+				team = new TournamentTeam(player, null);
+			}
+			
+			if (!TournamentMatch1x1.getInstance().checkConditions(team))
+			{
+				return false;
+			}
+			if (TournamentManager.getInstance().getRegisteredTournamentTeams().containsKey(team))
+			{
+				player.sendMessage("Your team already registered.");
+				return true;
+			}
+			
+			if (team.getLeader() != player)
+			{
+				player.sendMessage("Only Leaders can register.");
+				return false;
+			}
+			
+			if (TournamentMatch1x1.getInstance().register(team))
+			{
+				team.sendMessage("Your are on the 1x1 waiting list. ");
+				return true;
+			}
+			
+		}
+		if (bypass.startsWith("bp_registerTournament2x2"))
+		{
+			if (!TournamentManager.getInstance().isRunning())
+			{
+				player.sendMessage("Tournament isn't Running!");
+				return false;
+			}
+			if (!player.isInTournamentTeam() || player.getTournamentTeam().getMembers().size() < 2)
+			{
+				player.sendMessage("You need to invite 1 players to register this mode.");
+			}
+			else
+			{
+				if (!TournamentMatch2x2.getInstance().checkConditions(team))
+				{
+					return false;
+				}
+				if (TournamentManager.getInstance().getRegisteredTournamentTeams().containsKey(team))
+				{
+					player.sendMessage("Your team already registered.");
+					return true;
+				}
+				
+				if (team.getLeader() != player)
+				{
+					player.sendMessage("Only Leaders can register.");
+					return false;
+				}
+				
+				if (TournamentMatch2x2.getInstance().register(team))
+				{
+					team.sendMessage("Your team is on the 2x2 waiting list. ");
+					return true;
+				}
+			}
+			TournamentManager.getInstance().showHtml(player, "fights/F2X2", TournamentFightType.F2X2);
+			
+		}
+		if (bypass.startsWith("bp_registerTournament3x3"))
+		{
+			if (!TournamentManager.getInstance().isRunning())
+			{
+				player.sendMessage("Tournament isn't Running!");
+				return false;
+			}
+			if (!player.isInTournamentTeam() || player.getTournamentTeam().getMembers().size() < 3)
+			{
+				player.sendMessage("You need to invite 2 players to register this mode.");
+			}
+			else
+			{
+				if (!TournamentMatch3x3.getInstance().checkConditions(team))
+				{
+					return false;
+				}
+				if (TournamentManager.getInstance().getRegisteredTournamentTeams().containsKey(team))
+				{
+					player.sendMessage("Your team already registered.");
+					return true;
+				}
+				
+				if (team.getLeader() != player)
+				{
+					player.sendMessage("Only Leaders can register.");
+					return false;
+				}
+				
+				if (TournamentMatch3x3.getInstance().register(team))
+				{
+					team.sendMessage("Your team is on the 3x3 waiting list. ");
+					return true;
+				}
+				
+			}
+			TournamentManager.getInstance().showHtml(player, "fights/F3X3", TournamentFightType.F3X3);
+			
+		}
+		
+		if (bypass.startsWith("bp_registerTournament4x4"))
+		{
+			if (!TournamentManager.getInstance().isRunning())
+			{
+				player.sendMessage("Tournament isn't Running!");
+				return false;
+			}
+			if (!player.isInTournamentTeam() || player.getTournamentTeam().getMembers().size() < 4)
+			{
+				player.sendMessage("You need to invite 3 players to register this mode.");
+			}
+			else
+			{
+				if (!TournamentMatch3x3.getInstance().checkConditions(team))
+				{
+					return false;
+				}
+				if (TournamentManager.getInstance().getRegisteredTournamentTeams().containsKey(team))
+				{
+					player.sendMessage("Your team already registered.");
+					return true;
+				}
+				
+				if (team.getLeader() != player)
+				{
+					player.sendMessage("Only Leaders can register.");
+					return false;
+				}
+				
+				if (TournamentMatch4x4.getInstance().register(team))
+				{
+					team.sendMessage("Your team is on the 4x4 waiting list. ");
+					return true;
+				}
+			}
+			TournamentManager.getInstance().showHtml(player, "fights/F4X4", TournamentFightType.F4X4);
+			
+		}
+		
+		if (bypass.startsWith("bp_registerTournament5x5"))
+		{
+			if (!TournamentManager.getInstance().isRunning())
+			{
+				player.sendMessage("Tournament isn't Running!");
+				return false;
+			}
+			if (!player.isInTournamentTeam() || player.getTournamentTeam().getMembers().size() < 5)
+			{
+				player.sendMessage("You need to invite 4 players to register this mode.");
+			}
+			else
+			{
+				if (!TournamentMatch3x3.getInstance().checkConditions(team))
+				{
+					return false;
+				}
+				if (TournamentManager.getInstance().getRegisteredTournamentTeams().containsKey(team))
+				{
+					player.sendMessage("Your team already registered.");
+					return true;
+				}
+				
+				if (team.getLeader() != player)
+				{
+					player.sendMessage("Only Leaders can register.");
+					return false;
+				}
+				
+				if (TournamentMatch5x5.getInstance().register(team))
+				{
+					team.sendMessage("Your team is on the 5x5 waiting list. ");
+					return true;
+				}
+			}
+			TournamentManager.getInstance().showHtml(player, "fights/F5X5", TournamentFightType.F5X5);
+			
+		}
+		
+		if (bypass.startsWith("bp_registerTournament9x9"))
+		{
+			if (!TournamentManager.getInstance().isRunning())
+			{
+				player.sendMessage("Tournament isn't Running!");
+				return false;
+			}
+			if (!player.isInTournamentTeam() || player.getTournamentTeam().getMembers().size() < 9)
+			{
+				player.sendMessage("You need to invite 8 players to register this mode.");
+			}
+			else
+			{
+				if (!TournamentMatch3x3.getInstance().checkConditions(team))
+				{
+					return false;
+				}
+				if (TournamentManager.getInstance().getRegisteredTournamentTeams().containsKey(team))
+				{
+					player.sendMessage("Your team already registered.");
+					return true;
+				}
+				
+				if (team.getLeader() != player)
+				{
+					player.sendMessage("Only Leaders can register.");
+					return false;
+				}
+				
+				if (TournamentMatch9x9.getInstance().register(team))
+				{
+					team.sendMessage("Your team is on the 9x9 waiting list. ");
+					return true;
+				}
+			}
+			TournamentManager.getInstance().showHtml(player, "fights/F9X9", TournamentFightType.F9X9);
+			
+		}
+		if (bypass.startsWith("bp_deleteTournamentTeam"))
+		{
+			
+			if (team != null)
+			{
+				team.disbandTeam();
+			}
+			else
+			{
+				player.sendMessage("You haven't a Tournament Team.");
+			}
+			TournamentManager.getInstance().showHtml(player, "main", TournamentFightType.NONE);
+		}
+		if (bypass.startsWith("bp_inviteTournamentMember"))
+		{
+			if (!TournamentManager.getInstance().isRunning())
+			{
+				player.sendMessage("Tournament isn't Running!");
+				return false;
+			}
+			if (TournamentManager.getInstance().isTournamentTeleporting())
+			{
+				player.sendMessage("Tournament is teleportind players, wait 30 seconds to invite someone.");
+				return false;
+			}
+			String nextMemberName = st.nextToken();
+			Player nextMember = World.getInstance().getPlayer(nextMemberName);
+			if (nextMember == player)
+			{
+				player.sendMessage("You can't invite yourself!");
+				return false;
+			}
+			
+			if (nextMember != null)
+			{
+				if (nextMember.isInTournamentTeam())
+				{
+					player.sendMessage("This player already in Tournament Team.");
+					return false;
+				}
+				if (nextMember.isInParty())
+				{
+					player.sendMessage("You can't players in party. Don't worry, party will be automatically created!");
+					return false;
+				}
+				if (team != null)
+				{
+					if (team.getLeader() != player)
+					{
+						player.sendMessage("Only Leaders can invite players.");
+						return false;
+					}
+				}
+				TournamentManager.getInstance().askJoinTeam(player, nextMember);
+			}
+			else
+			{
+				player.sendMessage("Player " + nextMemberName + " doesn't exists or is not online!");
+				return false;
+			}
+			
+		}
+		if (bypass.startsWith("bp_removeTournamentParticipation"))
+		{
+			if (!TournamentManager.getInstance().isRunning())
+			{
+				player.sendMessage("Tournament isn't Running!");
+				return false;
+			}
+			if (team != null)
+			{
+				if (TournamentManager.getInstance().getRegisteredTournamentTeams().containsKey(team))
+				{
+					TournamentManager.getInstance().getRegisteredTournamentTeams().remove(team);
+					team.sendMessage("Your team have been removed from Tournament Waiting List");
+				}
+				else
+				{
+					player.sendMessage("Your team isn't registered.");
+					TournamentManager.getInstance().showHtml(player, "main", TournamentFightType.NONE);
+					return false;
+				}
+			}
+			else
+			{
+				player.sendMessage("You haven't a Tournament Team.");
+			}
+			TournamentManager.getInstance().showHtml(player, "main", TournamentFightType.NONE);
+			
+		}
+		
+		if (bypass.startsWith("bp_createTournamentTeam"))
+		{
+			if (!TournamentManager.getInstance().isRunning())
+			{
+				player.sendMessage("Tournament isn't Running!");
+				return false;
+			}
+			if (player.getTournamentTeam() != null)
+			{
+				player.sendMessage("You can't create a new Tournament Team.");
+				return false;
+			}
+			
+			if (team == null)
+			{
+				team = new TournamentTeam(player, null);
+			}
+			else
+			{
+				player.sendMessage("Your Tournament Team has been already created, try to invite someone.");
+				return false;
+			}
+			TournamentManager.getInstance().showHtml(player, "main", TournamentFightType.NONE);
+			
+		}
+		else if (bypass.startsWith("bp_showTournamentPage"))
+		{
+			String page = st.nextToken();
+			TournamentManager.getInstance().showHtml(player, page, TournamentFightType.NONE);
+		}
+		else if (bypass.startsWith("bp_checkTournamentPlayer"))
+		{
+			String playerName = st.nextToken();
+			String type = st.nextToken();
+			int targetObjectId = PlayerInfoTable.getInstance().getPlayerObjectId(playerName);
+			TournamentManager.getInstance().showPlayerRankingData(player, targetObjectId, TournamentFightType.valueOf(type));
+		}
+		else if (bypass.startsWith("bp_tournamentRanking"))
+		{
+			String type = st.nextToken();
+			String rankType = st.nextToken();
+			TournamentManager.getInstance().showRanking(player, TournamentFightType.valueOf(type), rankType);
+		}
+		return false;
+	}
+	
+	@Override
+	public String[] getBypassHandlersList()
+	{
+		
+		return new String[]
+		{
+			"bp_checkTournamentPlayer",
+			"bp_showTournamentPage",
+			"bp_registerTournament1x1",
+			"bp_removeTournamentParticipation",
+			"bp_createTournamentTeam",
+			"bp_registerTournament2x2",
+			"bp_inviteTournamentMember",
+			"bp_deleteTournamentTeam",
+			"bp_tournamentTeamInfo",
+			"bp_inviteTournamentPage",
+			"bp_registerTournament3x3",
+			"bp_registerTournament4x4",
+			"bp_registerTournament5x5",
+			"bp_registerTournament9x9",
+			"bp_tournamentRanking",
+			"bp_leaveTournamentTeam"
+		
+		};
+	}
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/Commands/AdminTournament.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/Commands/AdminTournament.java
new file mode 100644
index 0000000..c7739ea
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/Commands/AdminTournament.java
@@ -0,0 +1,36 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.Commands;
+
+import net.sf.l2j.gameserver.handler.IAdminCommandHandler;
+import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+
+/**
+ * @author Rouxy
+ */
+public class AdminTournament implements IAdminCommandHandler
+{
+	
+	@Override
+	public void useAdminCommand(String command, Player player)
+	{
+		if (command.startsWith("admin_tour"))
+		{
+			if (TournamentManager.getInstance().isRunning())
+				TournamentManager.getInstance().finishEvent();
+			else
+				TournamentManager.getInstance().startEvent();
+		}
+		
+	}
+	
+	@Override
+	public String[] getAdminCommandList()
+	{
+		
+		return new String[]
+		{
+			"admin_tour"
+		};
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/Commands/VoiceTournament.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/Commands/VoiceTournament.java
new file mode 100644
index 0000000..356d986
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/Commands/VoiceTournament.java
@@ -0,0 +1,90 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.Commands;
+
+import java.util.StringTokenizer;
+
+import net.sf.l2j.gameserver.handler.IVoicedCommandHandler;
+import net.sf.l2j.gameserver.model.World;
+import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+
+/**
+ * @author Rouxy
+ */
+public class VoiceTournament implements IVoicedCommandHandler
+{
+	
+	@Override
+	public boolean useVoicedCommand(String command, Player player, String params)
+	{
+		StringTokenizer st = new StringTokenizer(command, " ");
+		st.nextToken();
+		TournamentTeam team = player.getTournamentTeam();
+		if (command.startsWith("mytour"))
+		{
+			TournamentManager.getInstance().showHtml(player, "myTour", TournamentFightType.NONE);
+		}
+		if (command.startsWith("tournamentinvite"))
+		{
+			if (!TournamentManager.getInstance().isRunning())
+			{
+				player.sendMessage("Tournament isn't Running!");
+				return false;
+			}
+			if (TournamentManager.getInstance().isTournamentTeleporting())
+			{
+				player.sendMessage("Tournament is teleportind players, wait 30 seconds to invite someone.");
+				return false;
+			}
+			String nextMemberName = st.nextToken();
+			Player nextMember = World.getInstance().getPlayer(nextMemberName);
+			if (nextMember == player)
+			{
+				player.sendMessage("You can't invite yourself!");
+				return false;
+			}
+			
+			if (nextMember != null)
+			{
+				if (nextMember.isInTournamentTeam())
+				{
+					player.sendMessage("This player already in Tournament Team.");
+					return false;
+				}
+				if (nextMember.isInParty())
+				{
+					player.sendMessage("You can't players in party. Don't worry, party will be automatically created!");
+					return false;
+				}
+				if (team != null)
+				{
+					if (team.getLeader() != player)
+					{
+						player.sendMessage("Only Leaders can invite players.");
+						return false;
+					}
+				}
+				TournamentManager.getInstance().askJoinTeam(player, nextMember);
+			}
+			else
+			{
+				player.sendMessage("Player " + nextMemberName + " doesn't exists or is not online!");
+				return false;
+			}
+		}
+		return false;
+	}
+	
+	@Override
+	public String[] getVoicedCommandList()
+	{
+		
+		return new String[]
+		{
+			"mytour",
+			"tournamentinvite"
+		};
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/Data/TournamentArenaParser.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/Data/TournamentArenaParser.java
new file mode 100644
index 0000000..3af095f
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/Data/TournamentArenaParser.java
@@ -0,0 +1,133 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.Data;
+
+import java.nio.file.Path;
+import java.util.ArrayList;
+import java.util.List;
+
+import org.w3c.dom.Document;
+import org.w3c.dom.NamedNodeMap;
+
+import net.sf.l2j.commons.data.StatSet;
+import net.sf.l2j.commons.data.xml.IXmlReader;
+import net.sf.l2j.commons.random.Rnd;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentArena;
+import net.sf.l2j.gameserver.model.location.Location;
+
+public class TournamentArenaParser implements IXmlReader
+{
+	
+	private List<TournamentArena> _arenas = new ArrayList<>();
+	// private int _lastDynamicId = 0;
+	
+	public TournamentArenaParser()
+	{
+		load();
+	}
+	
+	public void reload()
+	{
+		// Reset dynamic id.
+		// _lastDynamicId = 0;
+		_arenas.clear();
+		load();
+	}
+	
+	public static TournamentArenaParser getInstance()
+	{
+		return SingleTonHolder._instance;
+	}
+	
+	private static class SingleTonHolder
+	{
+		protected static TournamentArenaParser _instance = new TournamentArenaParser();
+	}
+	
+	@Override
+	public void load()
+	{
+		parseFile("./data/xml/TournamentData/Arenas.xml");
+		LOGGER.info("Loaded {} Tournament Arenas.", _arenas.size());
+	}
+	
+	@Override
+	public void parseDocument(Document doc, Path path)
+	{
+		
+		// StatsSet used to feed informations. Cleaned on every entry.
+		final StatSet set = new StatSet();
+		forEach(doc, "list", listNode -> forEach(listNode, "arena", arenaNode ->
+		{
+			
+			final NamedNodeMap attrs = arenaNode.getAttributes();
+			// final Node attribute = attrs.getNamedItem("id");
+			// final int arenaId = attribute == null ? _lastDynamicId++ : Integer.parseInt(attribute.getNodeValue());
+			
+			// parse and feed attributes
+			parseAndFeed(attrs, set);
+			
+			final List<Location> teamOneLocs = new ArrayList<>();
+			forEach(arenaNode, "team_one_loc", nodeNode ->
+			{
+				final NamedNodeMap nodeAttrs = nodeNode.getAttributes();
+				teamOneLocs.add(new Location(parseInteger(nodeAttrs, "x"), parseInteger(nodeAttrs, "y"), parseInteger(nodeAttrs, "z")));
+			});
+			
+			final List<Location> teamTwoLocs = new ArrayList<>();
+			forEach(arenaNode, "team_two_loc", nodeNode ->
+			{
+				final NamedNodeMap nodeAttrs = nodeNode.getAttributes();
+				teamTwoLocs.add(new Location(parseInteger(nodeAttrs, "x"), parseInteger(nodeAttrs, "y"), parseInteger(nodeAttrs, "z")));
+			});
+			TournamentArena arena = new TournamentArena(set, teamOneLocs, teamTwoLocs);
+			_arenas.add(arena);
+			
+		}));
+		
+	}
+	
+	public List<TournamentArena> getArenasForType(TournamentFightType type)
+	{
+		List<TournamentArena> list = new ArrayList<>();
+		for (TournamentArena arena : _arenas)
+		{
+			if (arena.getTypes().contains(type))
+			{
+				list.add(arena);
+			}
+		}
+		return list;
+	}
+	
+	public TournamentArena getRandomArenaForType(TournamentFightType type)
+	{
+		return getArenasForType(type).get(Rnd.get(getArenasForType(type).size()));
+	}
+	
+	public TournamentArena getRandomArena()
+	{
+		return _arenas.get(Rnd.get(_arenas.size()));
+	}
+	
+	public TournamentArena getArena(int id)
+	{
+		return _arenas.get(id);
+	}
+	
+	/**
+	 * @return the arenas
+	 */
+	public List<TournamentArena> getArenas()
+	{
+		return _arenas;
+	}
+	
+	/**
+	 * @param arenas the arenas to set
+	 */
+	public void setArenas(List<TournamentArena> arenas)
+	{
+		this._arenas = arenas;
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/TournamentManager.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/TournamentManager.java
new file mode 100644
index 0000000..43aa11d
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/TournamentManager.java
@@ -0,0 +1,1244 @@
+package net.sf.l2j.gameserver.model.entity.Tournament;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.text.SimpleDateFormat;
+import java.util.ArrayList;
+import java.util.Calendar;
+import java.util.HashMap;
+import java.util.LinkedList;
+import java.util.List;
+import java.util.Map;
+import java.util.StringTokenizer;
+import java.util.concurrent.ScheduledFuture;
+import java.util.logging.Logger;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.commons.pool.ConnectionPool;
+import net.sf.l2j.commons.pool.ThreadPool;
+import net.sf.l2j.commons.random.Rnd;
+import net.sf.l2j.gameserver.data.sql.PlayerInfoTable;
+import net.sf.l2j.gameserver.data.sql.SpawnTable;
+import net.sf.l2j.gameserver.data.xml.NpcData;
+import net.sf.l2j.gameserver.enums.SayType;
+import net.sf.l2j.gameserver.handler.AdminCommandHandler;
+import net.sf.l2j.gameserver.handler.VoicedCommandHandler;
+import net.sf.l2j.gameserver.model.World;
+import net.sf.l2j.gameserver.model.actor.Creature;
+import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.actor.template.NpcTemplate;
+import net.sf.l2j.gameserver.model.entity.Tournament.Commands.AdminTournament;
+import net.sf.l2j.gameserver.model.entity.Tournament.Commands.VoiceTournament;
+import net.sf.l2j.gameserver.model.entity.Tournament.Data.TournamentArenaParser;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+import net.sf.l2j.gameserver.model.entity.Tournament.tasks.TournamentFight;
+import net.sf.l2j.gameserver.model.entity.Tournament.tasks.TournamentSearchFights;
+import net.sf.l2j.gameserver.model.location.Location;
+import net.sf.l2j.gameserver.model.spawn.Spawn;
+import net.sf.l2j.gameserver.network.SystemMessageId;
+import net.sf.l2j.gameserver.network.serverpackets.ConfirmDlg;
+import net.sf.l2j.gameserver.network.serverpackets.L2GameServerPacket;
+import net.sf.l2j.gameserver.network.serverpackets.MagicSkillUse;
+import net.sf.l2j.gameserver.network.serverpackets.NpcHtmlMessage;
+import net.sf.l2j.util.Mysql;
+import net.sf.l2j.util.PlayerVariables;
+
+/**
+ * @author Rouxy
+ */
+public class TournamentManager
+{
+	private static final Logger _log = Logger.getLogger(TournamentManager.class.getName());
+	private Map<TournamentTeam, TournamentFightType> registeredTournamentTeams = new HashMap<>();
+	private Map<Integer, TournamentFight> currentFights = new HashMap<>();
+	private Calendar nextEvent;
+	private final SimpleDateFormat format = new SimpleDateFormat("HH:mm");
+	private Spawn _npcSpawn;
+	private boolean running;
+	private ScheduledFuture<?> finishEventTask = null;
+	private boolean tournamentTeleporting;
+	private int allTimeFights = 0;
+	
+	public TournamentManager()
+	{
+		TournamentArenaParser.getInstance();
+		ThreadPool.scheduleAtFixedRate(new TournamentSearchFights(TournamentFightType.F1X1), 0, Config.TOURNAMENT_TIME_SEARCH_FIGHTS * 1000);
+		ThreadPool.scheduleAtFixedRate(new TournamentSearchFights(TournamentFightType.F2X2), 0, Config.TOURNAMENT_TIME_SEARCH_FIGHTS * 1000);
+		ThreadPool.scheduleAtFixedRate(new TournamentSearchFights(TournamentFightType.F3X3), 0, Config.TOURNAMENT_TIME_SEARCH_FIGHTS * 1000);
+		ThreadPool.scheduleAtFixedRate(new TournamentSearchFights(TournamentFightType.F4X4), 0, Config.TOURNAMENT_TIME_SEARCH_FIGHTS * 1000);
+		ThreadPool.scheduleAtFixedRate(new TournamentSearchFights(TournamentFightType.F5X5), 0, Config.TOURNAMENT_TIME_SEARCH_FIGHTS * 1000);
+		ThreadPool.scheduleAtFixedRate(new TournamentSearchFights(TournamentFightType.F9X9), 0, Config.TOURNAMENT_TIME_SEARCH_FIGHTS * 1000);
+		VoicedCommandHandler.getInstance().registerHandler(new VoiceTournament());
+		AdminCommandHandler.getInstance().registerHandler(new AdminTournament());
+		
+		startCalculationOfNextEventTime();
+	}
+	
+	public static TournamentManager getInstance()
+	{
+		return SingleTonHolder._instance;
+	}
+	
+	private static class SingleTonHolder
+	{
+		protected static TournamentManager _instance = new TournamentManager();
+	}
+	
+	public String getNextTime()
+	{
+		if (nextEvent.getTime() != null)
+		{
+			return format.format(nextEvent.getTime());
+		}
+		return "Erro";
+	}
+	
+	public void startCalculationOfNextEventTime()
+	{
+		try
+		{
+			Calendar currentTime = Calendar.getInstance();
+			Calendar testStartTime = null;
+			long flush2 = 0L;
+			long timeL = 0L;
+			int count = 0;
+			for (String timeOfDay : Config.TOURNAMENT_EVENT_INTERVAL_BY_TIME_OF_DAY)
+			{
+				testStartTime = Calendar.getInstance();
+				testStartTime.setLenient(true);
+				String[] splitTimeOfDay = timeOfDay.split(":");
+				testStartTime.set(11, Integer.parseInt(splitTimeOfDay[0]));
+				testStartTime.set(12, Integer.parseInt(splitTimeOfDay[1]));
+				testStartTime.set(13, 0);
+				if (testStartTime.getTimeInMillis() < currentTime.getTimeInMillis())
+				{
+					testStartTime.add(5, 1);
+				}
+				timeL = testStartTime.getTimeInMillis() - currentTime.getTimeInMillis();
+				if (count == 0)
+				{
+					flush2 = timeL;
+					nextEvent = testStartTime;
+				}
+				if (timeL < flush2)
+				{
+					flush2 = timeL;
+					nextEvent = testStartTime;
+				}
+				count++;
+			}
+			_log.info("[Tournament]: Next Event time: " + nextEvent.getTime().toString());
+			ThreadPool.schedule(new StartEventTask(), flush2);
+		}
+		catch (Exception e)
+		{
+			System.out.println("[Tournament]: " + e);
+		}
+	}
+	
+	public static void toAllOnlinePlayers(L2GameServerPacket packet)
+	{
+		for (Player player : World.getInstance().getPlayers())
+		{
+			if (player.isOnline())
+				player.sendPacket(packet);
+		}
+	}
+	
+	public void announceToAllOnlinePlayers(String text)
+	{
+		for (Player player : World.getInstance().getPlayers())
+		{
+			if (player.isOnline())
+				player.sendChatMessage(0, SayType.CRITICAL_ANNOUNCE, "", text);
+		}
+	}
+	
+	class FinishEventTask implements Runnable
+	{
+		FinishEventTask()
+		{
+			
+		}
+		
+		@Override
+		public void run()
+		{
+			finishEvent();
+			
+		}
+		
+	}
+	
+	public void finishEvent()
+	{
+		_log.info("----------------------------------------------------------------------------");
+		_log.info("[Tournament]: Event Finished.");
+		_log.info("----------------------------------------------------------------------------");
+		announceToAllOnlinePlayers("[Tournament]: Event Finished");
+		announceToAllOnlinePlayers("[Tournament]: All fights have been stored");
+		announceToAllOnlinePlayers("[Tournament]: Next event: " + getNextTime());
+		unspawnNpc();
+		setRunning(false);
+		if (getFinishEventTask() != null)
+		{
+			getFinishEventTask().cancel(true);
+			finishEventTask = null;
+		}
+	}
+	
+	public void startEvent()
+	{
+		_log.info("----------------------------------------------------------------------------");
+		_log.info("[Tournament]: Event Started.");
+		_log.info("----------------------------------------------------------------------------");
+		spawnNpcEvent();
+		setRunning(true);
+		announceToAllOnlinePlayers("[Tournament]: Party and Non Event PvP");
+		announceToAllOnlinePlayers("[Tournament]: Battles: 1x1 / 2x2 / 3x3 / 4x4 / 5x5 / 9x9");
+		announceToAllOnlinePlayers("[Tournament]: Teleport in the GK to (Tournament) Zone");
+		announceToAllOnlinePlayers("[Tournament]: Event duration: " + Config.TOURNAMENT_EVENT_DURATION + " minutes");
+		setFinishEventTask(ThreadPool.schedule(new FinishEventTask(), Config.TOURNAMENT_EVENT_DURATION * 60 * 1000));
+		for (Player player : World.getInstance().getPlayers())
+		{
+			askTeleport(player);
+		}
+	}
+	
+	class StartEventTask implements Runnable
+	{
+		@Override
+		public void run()
+		{
+			startEvent();
+			
+		}
+		
+	}
+	
+	public void unspawnNpc()
+	{
+		if (_npcSpawn == null)
+		{
+			return;
+		}
+		_npcSpawn.getNpc().deleteMe();
+		_npcSpawn.setRespawnState(false);
+		SpawnTable.getInstance().deleteSpawn(_npcSpawn, true);
+	}
+	
+	public void spawnNpcEvent()
+	{
+		
+		NpcTemplate tmpl = NpcData.getInstance().getTemplate(Config.TOURNAMENT_NPC_ID);
+		Location npcLoc = Config.TOURNAMENT_NPC_LOCATION;
+		try
+		{
+			_npcSpawn = new Spawn(tmpl);
+			
+			_npcSpawn.setLoc(npcLoc.getX(), npcLoc.getY(), npcLoc.getZ(), Rnd.get(65535));
+			_npcSpawn.setRespawnDelay(1);
+			
+			SpawnTable.getInstance().addSpawn(_npcSpawn, false);
+			
+			_npcSpawn.setRespawnState(true);
+			_npcSpawn.doSpawn(false);
+			_npcSpawn.getNpc().getStatus().setHp(9.99999999E8D);
+			_npcSpawn.getNpc().isAggressive();
+			_npcSpawn.getNpc().decayMe();
+			_npcSpawn.getNpc().spawnMe(_npcSpawn.getNpc().getX(), _npcSpawn.getNpc().getY(), _npcSpawn.getNpc().getZ());
+			_npcSpawn.getNpc().broadcastPacket(new MagicSkillUse(_npcSpawn.getNpc(), _npcSpawn.getNpc(), 1034, 1, 1, 1));
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		
+	}
+	
+	public void askJoinTeam(Player leader, Player target)
+	{
+		ConfirmDlg confirm = new ConfirmDlg(SystemMessageId.S1.getId());
+		confirm.addString("Do you wish to join " + leader.getName() + "'s Tournament Team?");
+		confirm.addTime(30000);
+		target.setTournamentTeamRequesterId(leader.getObjectId());
+		target.setTournamentTeamBeingInvited(true);
+		target.sendPacket(confirm);
+		leader.sendMessage(target.getName() + " was invited to your team.");
+		
+	}
+	
+	public void askTeleport(Player player)
+	{
+		ConfirmDlg confirm = new ConfirmDlg(SystemMessageId.S1.getId());
+		confirm.addString("Do you wish to teleport to Tournament Zone?");
+		confirm.addTime(30000);
+		setTournamentTeleporting(true);
+		ThreadPool.schedule(new Runnable()
+		{
+			@Override
+			public void run()
+			{
+				setTournamentTeleporting(false);
+			}
+		}, 30000);
+		player.sendPacket(confirm);
+	}
+	
+	public void debugInfo(String text)
+	{
+		_log.info("[Tournament]: " + text);
+	}
+	
+	public List<TournamentFight> getCurrentFights(TournamentFightType type)
+	{
+		List<TournamentFight> list = new ArrayList<>();
+		for (Map.Entry<Integer, TournamentFight> entry : currentFights.entrySet())
+		{
+			if (entry.getValue().getFightType() == type)
+				list.add(entry.getValue());
+		}
+		return list;
+	}
+	
+	public TournamentFight getFight(int id)
+	{
+		return currentFights.get(id);
+	}
+	
+	public Map<Integer, TournamentFight> getCurrentFights()
+	{
+		return currentFights;
+	}
+	
+	public void setCurrentFights(Map<Integer, TournamentFight> currentFights)
+	{
+		this.currentFights = currentFights;
+	}
+	
+	public void onDisconnect(Player player)
+	{
+		if (player.isInTournamentTeam())
+		{
+			TournamentTeam team = player.getTournamentTeam();
+			team.getMembers().remove(player);
+			team.sendMessage(player.getName() + " left the Tournament Team.");
+			if (team.getMembers().size() <= 1)
+			{
+				team.disbandTeam();
+				return;
+			}
+			if (team.isLeader(player))
+			{
+				Player newLeader = team.getMembers().get(Rnd.get(team.getMembers().size()));
+				if (newLeader != null)
+				{
+					team.setLeader(newLeader);
+					newLeader.sendMessage("You has became the new Tournament Team Leader");
+				}
+				team.sendMessage(newLeader + " has became the new Team Leader");
+				
+			}
+		}
+	}
+	
+	public void onKill(Creature killer, Player killed)
+	{
+		if (killed.isInTournamentMatch())
+		{
+			if (killer instanceof Player)
+			{
+				Player killerPlayer = killer.getActingPlayer();
+				if (killerPlayer.isInTournamentMatch())
+				{
+					if (killerPlayer.getTournamentFightId() == killed.getTournamentFightId() && killed.getTournamentFightId() != 0)
+					{
+						TournamentFight fight = TournamentManager.getInstance().getFight(killed.getTournamentFightId());
+						if (fight != null)
+						{
+							// add single kill to killer
+							killerPlayer.addTournamentKill(killerPlayer.getTournamentFightType());
+							killerPlayer.sendMessage("Killed Tournament Enemy: " + killed.getName());
+							
+							if (killed.getTournamentTeam() != null)
+							{
+								if (killed.getTournamentTeam().teamIsDefeated())
+								{
+									fight.finish();
+								}
+							}
+						}
+					}
+				}
+			}
+		}
+	}
+	
+	public List<TournamentTeam> getRegisteredTeamsByType(TournamentFightType type)
+	{
+		List<TournamentTeam> teams = new ArrayList<>();
+		for (Map.Entry<TournamentTeam, TournamentFightType> entry : registeredTournamentTeams.entrySet())
+		{
+			if (entry.getValue().equals(type))
+			{
+				teams.add(entry.getKey());
+			}
+		}
+		return teams;
+	}
+	
+	/**
+	 * @return the tournamentTeams
+	 */
+	public Map<TournamentTeam, TournamentFightType> getRegisteredTournamentTeams()
+	{
+		return registeredTournamentTeams;
+	}
+	
+	/**
+	 * @param tournamentTeams the tournamentTeams to set
+	 */
+	public void setTournamentTeams(Map<TournamentTeam, TournamentFightType> tournamentTeams)
+	{
+		this.registeredTournamentTeams = tournamentTeams;
+	}
+	
+	public boolean isInTournamentMode(Player player)
+	{
+		for (Map.Entry<TournamentTeam, TournamentFightType> entry : registeredTournamentTeams.entrySet())
+		{
+			if (entry.getKey().getMembers().contains(player))
+			{
+				return true;
+			}
+			
+		}
+		return false;
+	}
+	
+	// Npc html part
+	
+	public void showHtml(Player player, String page, TournamentFightType type)
+	{
+		NpcHtmlMessage htm = new NpcHtmlMessage(0);
+		htm.setFile("data/html/mods/tournament/" + page + ".htm");
+		
+		htm.replace("%missingMembers%", getMembersMessageForFightType(player, type));
+		htm.replace("%memberslist%", player.getTournamentTeam() != null ? generateMemberList(player.getTournamentTeam()) : "<br><font color=ff0000>You haven't a Tournament Team</font>");
+		htm.replace("%inviteBoxRegButton%", getInviteBoxOrRegisterButton(player, type));
+		htm.replace("%fightType%", type.equals(TournamentFightType.NONE) ? "" : type.name().substring(1).toLowerCase());
+		
+		// Fight Data
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentVictories().entrySet())
+		{
+			htm.replace("%victories" + entry.getKey().name() + "%", player.getTournamentVictories().get(entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentDefeats().entrySet())
+		{
+			htm.replace("%defeats" + entry.getKey().name() + "%", player.getTournamentDefeats().get(entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentTies().entrySet())
+		{
+			htm.replace("%ties" + entry.getKey().name() + "%", player.getTournamentTies().get(entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentKills().entrySet())
+		{
+			htm.replace("%kills" + entry.getKey().name() + "%", player.getTournamentKills().get(entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentDamage().entrySet())
+		{
+			htm.replace("%damage" + entry.getKey().name() + "%", player.getTournamentDamage().get(entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentDamage().entrySet())
+		{
+			htm.replace("%dpf" + entry.getKey().name() + "%", getDamagePerFight(player, entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentVictories().entrySet())
+		{
+			htm.replace("%fightsDone" + entry.getKey().name() + "%", player.getTournamentFightsDone(entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentVictories().entrySet())
+		{
+			htm.replace("%teamsReg" + entry.getKey().name() + "%", registeredTournamentTeams.size());
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentVictories().entrySet())
+		{
+			htm.replace("%activeFights" + entry.getKey().name() + "%", getCurrentFights(entry.getKey()).size());
+		}
+		
+		htm.replace("%allTimeFights%", getAllTimeFights());
+		htm.replace("%tourPoints%", player.getTournamentPoints());
+		htm.replace("%killstotal%", player.getTotalTournamentKills());
+		htm.replace("%totalDmg%", player.getTournamentTotalDamage());
+		htm.replace("%playerName%", player.getName());
+		htm.replace("%dpfTotal%", getDamagePerFight(player));
+		htm.replace("%wdt%", getWinDefeatTie(player));
+		htm.replace("%totalFights%", player.getTotalTournamentFightsDone());
+		
+		player.sendPacket(htm);
+	}
+	
+	public String getInviteBoxOrRegisterButton(Player player, TournamentFightType type)
+	{
+		StringBuilder sb = new StringBuilder();
+		if (getMissingMembersForFightType(player, type) == 0)
+		{
+			sb.append("<table width=300>");
+			sb.append("<tr>");
+			sb.append("<td align=center><font color=LEVEL> Your team is ready!!</font></td>");
+			sb.append("</tr>");
+			sb.append("</table>");
+		}
+		else
+		{
+			sb.append("<center>");
+			sb.append("Type the name of your partner or use command: <br1><font color=994992>\".tournamentinvite playername\"</font>");
+			sb.append("</center>");
+			sb.append("<table width=300>");
+			sb.append("<tr>");
+			sb.append("<td>Player Name</td>");
+			sb.append("<td><edit var=\"playerName\" width=120 height=15></td>");
+			sb.append("<td><button value=\"Invite\" action=\"bypass -h bp_inviteTournamentMember $playerName\" width=45 height=15 back=\"sek.cbui94\" fore=\"sek.cbui92\"></td>");
+			sb.append("</tr>");
+			sb.append("</table>");
+		}
+		
+		return sb.toString();
+	}
+	
+	public String getMembersMessageForFightType(Player player, TournamentFightType type)
+	{
+		if (!player.isInTournamentTeam())
+		{
+			return "<br><font color=ff0000>You haven't a Tournament Team</font>";
+		}
+		if (type != TournamentFightType.NONE)
+		{
+			return "<br>You need to invite <font color=LEVEL>" + getMissingMembersForFightType(player, type) + "</font> to register " + type.name().substring(1).toLowerCase() + " fights.";
+		}
+		return "";
+	}
+	
+	public int getMissingMembersForFightType(Player player, TournamentFightType type)
+	{
+		int membersCount = 0;
+		if (!player.isInTournamentTeam())
+		{
+			return -1;
+		}
+		membersCount = player.getTournamentTeam().getMembers().size();
+		switch (type)
+		{
+			case F1X1:
+				return 0;
+			case F2X2:
+				return 2 - membersCount;
+			case F3X3:
+				return 3 - membersCount;
+			case F4X4:
+				return 4 - membersCount;
+			case F5X5:
+				return 5 - membersCount;
+			case F9X9:
+				return 9 - membersCount;
+			default:
+				return -1;
+		}
+	}
+	
+	public String generateMemberList(TournamentTeam team)
+	{
+		StringBuilder sb = new StringBuilder();
+		int bgcolor = 0;
+		for (Player member : team.getMembers())
+		{
+			sb.append("<img src=\"Sek.cbui371\" width=300 height=1>");
+			if (bgcolor % 2 == 0)
+				sb.append("<table width=315  bgcolor=090000>");
+			else
+				sb.append("<table width=315 bgcolor=000000>");
+			
+			sb.append("<tr>");
+			sb.append("<td fixwidth=50></td>");
+			sb.append("<td align=center>");
+			sb.append("<font color=LEVEL>" + member.getName() + "</font>");
+			sb.append("</td>");
+			sb.append("<td fixwidth=50></td>");
+			sb.append("</tr>");
+			sb.append("</table>");
+			bgcolor++;
+		}
+		
+		return sb.toString();
+	}
+	
+	public void onPlayerEnter(Player player)
+	{
+		// catch data from memo
+		loadTournamentData(player);
+		
+		// check data and insert if have no result for all types
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentVictories().entrySet())
+		{
+			checkData(player, entry.getKey());
+		}
+	}
+	
+	public void checkData(Player player, TournamentFightType type)
+	{
+		
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("SELECT * FROM tournament_player_data WHERE obj_id=? AND fight_type=?");
+			offline.setInt(1, player.getObjectId());
+			offline.setString(2, type.name());
+			rs = offline.executeQuery();
+			boolean hasResult = rs.next();
+			if (!hasResult)
+			{
+				insertData(player, type);
+			}
+			
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+		
+	}
+	
+	public void insertData(Player player, TournamentFightType type)
+	{
+		
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("REPLACE INTO tournament_player_data (obj_id, fight_type, fights_done, victories, defeats, ties, kills, damage, wdt, dpf) VALUES (?,?,?,?,?,?,?,?,?,?)");
+			offline.setInt(1, player.getObjectId());
+			offline.setString(2, type.name());
+			offline.setInt(3, player.getTotalTournamentFightsDone());
+			offline.setInt(4, player.getTournamentVictories().get(type));
+			offline.setInt(5, player.getTournamentDefeats().get(type));
+			offline.setInt(6, player.getTournamentTies().get(type));
+			offline.setInt(7, player.getTournamentKills().get(type));
+			offline.setInt(8, player.getTournamentDamage().get(type));
+			offline.setString(9, "" + getWinDefeatTie(player, type));
+			offline.setInt(10, getDamagePerFight(player, type));
+			offline.execute();
+			
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+		
+	}
+	
+	public void updateData(Player player, TournamentFightType type)
+	{
+		
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("UPDATE tournament_player_data SET fights_done=?, victories=?, defeats=?, ties=?, kills=?, damage=?, wdt=?, dpf=? WHERE obj_id=? AND fight_type=?");
+			offline.setInt(1, player.getTotalTournamentFightsDone());
+			offline.setInt(2, player.getTournamentVictories().get(type));
+			offline.setInt(3, player.getTournamentDefeats().get(type));
+			offline.setInt(4, player.getTournamentTies().get(type));
+			offline.setInt(5, player.getTournamentKills().get(type));
+			offline.setInt(6, player.getTournamentDamage().get(type));
+			offline.setString(7, "" + getWinDefeatTie(player, type));
+			offline.setInt(8, getDamagePerFight(player, type));
+			offline.setInt(9, player.getObjectId());
+			offline.setString(10, type.name());
+			offline.execute();
+			
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+		
+	}
+	
+	public void initializeTournamentMaps(Player player)
+	{
+		player.getTournamentDamage().put(TournamentFightType.F1X1, 0);
+		player.getTournamentDamage().put(TournamentFightType.F2X2, 0);
+		player.getTournamentDamage().put(TournamentFightType.F3X3, 0);
+		player.getTournamentDamage().put(TournamentFightType.F4X4, 0);
+		player.getTournamentDamage().put(TournamentFightType.F5X5, 0);
+		player.getTournamentDamage().put(TournamentFightType.F9X9, 0);
+		
+		player.getTournamentDefeats().put(TournamentFightType.F1X1, 0);
+		player.getTournamentDefeats().put(TournamentFightType.F2X2, 0);
+		player.getTournamentDefeats().put(TournamentFightType.F3X3, 0);
+		player.getTournamentDefeats().put(TournamentFightType.F4X4, 0);
+		player.getTournamentDefeats().put(TournamentFightType.F5X5, 0);
+		player.getTournamentDefeats().put(TournamentFightType.F9X9, 0);
+		
+		player.getTournamentVictories().put(TournamentFightType.F1X1, 0);
+		player.getTournamentVictories().put(TournamentFightType.F2X2, 0);
+		player.getTournamentVictories().put(TournamentFightType.F3X3, 0);
+		player.getTournamentVictories().put(TournamentFightType.F4X4, 0);
+		player.getTournamentVictories().put(TournamentFightType.F5X5, 0);
+		player.getTournamentVictories().put(TournamentFightType.F9X9, 0);
+		
+		player.getTournamentTies().put(TournamentFightType.F1X1, 0);
+		player.getTournamentTies().put(TournamentFightType.F2X2, 0);
+		player.getTournamentTies().put(TournamentFightType.F3X3, 0);
+		player.getTournamentTies().put(TournamentFightType.F4X4, 0);
+		player.getTournamentTies().put(TournamentFightType.F5X5, 0);
+		player.getTournamentTies().put(TournamentFightType.F9X9, 0);
+		
+		player.getTournamentKills().put(TournamentFightType.F1X1, 0);
+		player.getTournamentKills().put(TournamentFightType.F2X2, 0);
+		player.getTournamentKills().put(TournamentFightType.F3X3, 0);
+		player.getTournamentKills().put(TournamentFightType.F4X4, 0);
+		player.getTournamentKills().put(TournamentFightType.F5X5, 0);
+		player.getTournamentKills().put(TournamentFightType.F9X9, 0);
+	}
+	
+	// store/load fights methods
+	public void loadTournamentData(Player player)
+	{
+		initializeTournamentMaps(player);
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("SELECT * FROM character_memo_alt WHERE obj_id =?");
+			offline.setInt(1, player.getObjectId());
+			rs = offline.executeQuery();
+			
+			while (rs.next())
+			{
+				if (rs.getString("name").startsWith("Tournament"))
+				{
+					StringTokenizer st = new StringTokenizer(rs.getString("name"), "-");
+					st.nextToken(); // "Tournament"
+					switch (st.nextToken())
+					{
+						case "Victories":
+							if (st.hasMoreTokens())
+							{
+								player.getTournamentVictories().put(TournamentFightType.valueOf(st.nextToken()), rs.getInt("value"));
+							}
+							break;
+						case "Defeats":
+							if (st.hasMoreTokens())
+							{
+								player.getTournamentDefeats().put(TournamentFightType.valueOf(st.nextToken()), rs.getInt("value"));
+							}
+							break;
+						case "Ties":
+							if (st.hasMoreTokens())
+							{
+								player.getTournamentTies().put(TournamentFightType.valueOf(st.nextToken()), rs.getInt("value"));
+							}
+							break;
+						case "Kills":
+							if (st.hasMoreTokens())
+							{
+								player.getTournamentKills().put(TournamentFightType.valueOf(st.nextToken()), rs.getInt("value"));
+							}
+							break;
+						
+						case "Damage":
+							if (st.hasMoreTokens())
+							{
+								player.getTournamentDamage().put(TournamentFightType.valueOf(st.nextToken()), rs.getInt("value"));
+							}
+							break;
+						case "Points":
+							player.setTournamentPoints(rs.getInt("value"));
+							break;
+					}
+					
+				}
+				
+			}
+			
+			con.close();
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+	}
+	
+	public int getTournamentPlayerFightsDone(int objectId, TournamentFightType type)
+	{
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		int fights = 0;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("SELECT * FROM character_memo_alt WHERE obj_id =?");
+			offline.setInt(1, objectId);
+			rs = offline.executeQuery();
+			
+			while (rs.next())
+			{
+				if (rs.getString("name").startsWith("Tournament"))
+				{
+					StringTokenizer st = new StringTokenizer(rs.getString("name"), "-");
+					st.nextToken(); // "Tournament"
+					switch (st.nextToken())
+					{
+						case "Victories":
+						case "Defeats":
+						case "Ties":
+							if (st.hasMoreTokens() && st.nextToken().startsWith(type.name()))
+							{
+								fights += rs.getInt("value");
+							}
+							break;
+						
+					}
+					
+				}
+				
+			}
+			
+			con.close();
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+		return fights;
+	}
+	
+	public void showPlayerTournamentData(Player player, int targetObjectId, TournamentFightType type, Map<TournamentFightType, Integer> tournamentKills, Map<TournamentFightType, Integer> tournamentVictories, Map<TournamentFightType, Integer> tournamentDefeats, Map<TournamentFightType, Integer> tournamentTies, Map<TournamentFightType, Integer> tournamentDamage)
+	{
+		NpcHtmlMessage htm = new NpcHtmlMessage(0);
+		htm.setFile("data/html/mods/tournament/ranking/info/playerInfo" + type.name() + ".htm");
+		
+		// Fight Data
+		for (Map.Entry<TournamentFightType, Integer> entry : tournamentVictories.entrySet())
+		{
+			htm.replace("%victories" + entry.getKey().name() + "%", tournamentVictories.get(entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : tournamentDefeats.entrySet())
+		{
+			htm.replace("%defeats" + entry.getKey().name() + "%", tournamentDefeats.get(entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : tournamentTies.entrySet())
+		{
+			htm.replace("%ties" + entry.getKey().name() + "%", tournamentTies.get(entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : tournamentKills.entrySet())
+		{
+			htm.replace("%kills" + entry.getKey().name() + "%", tournamentKills.get(entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : tournamentDamage.entrySet())
+		{
+			htm.replace("%damage" + entry.getKey().name() + "%", tournamentDamage.get(entry.getKey()));
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : tournamentDamage.entrySet())
+		{
+			htm.replace("%dpf" + entry.getKey().name() + "%", "Not Showing");
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentVictories().entrySet())
+		{
+			htm.replace("%fightsDone" + entry.getKey().name() + "%", getTournamentPlayerFightsDone(targetObjectId, type));
+		}
+		
+		htm.replace("%tourPoints%", player.getTournamentPoints());
+		htm.replace("%killstotal%", player.getTotalTournamentKills());
+		htm.replace("%totalDmg%", player.getTournamentTotalDamage());
+		htm.replace("%playerName%", player.getName());
+		htm.replace("%dpfTotal%", getDamagePerFight(player));
+		htm.replace("%wdt%", getWinDefeatTie(player));
+		htm.replace("%totalFights%", player.getTotalTournamentFightsDone());
+		
+		player.sendPacket(htm);
+	}
+	
+	public void showPlayerRankingData(Player player, int targetObjectId, TournamentFightType type)
+	{
+		Map<TournamentFightType, Integer> tournamentKills = new HashMap<>();
+		Map<TournamentFightType, Integer> tournamentVictories = new HashMap<>();
+		Map<TournamentFightType, Integer> tournamentDefeats = new HashMap<>();
+		Map<TournamentFightType, Integer> tournamentTies = new HashMap<>();
+		Map<TournamentFightType, Integer> tournamentDamage = new HashMap<>();
+		
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("SELECT * FROM character_memo_alt WHERE obj_id =?");
+			offline.setInt(1, targetObjectId);
+			rs = offline.executeQuery();
+			
+			while (rs.next())
+			{
+				if (rs.getString("name").startsWith("Tournament"))
+				{
+					StringTokenizer st = new StringTokenizer(rs.getString("name"), "-");
+					st.nextToken(); // "Tournament"
+					switch (st.nextToken())
+					{
+						case "Victories":
+							if (st.hasMoreTokens())
+							{
+								tournamentVictories.put(TournamentFightType.valueOf(st.nextToken()), rs.getInt("value"));
+							}
+							break;
+						case "Defeats":
+							if (st.hasMoreTokens())
+							{
+								tournamentDefeats.put(TournamentFightType.valueOf(st.nextToken()), rs.getInt("value"));
+							}
+							break;
+						case "Ties":
+							if (st.hasMoreTokens())
+							{
+								tournamentTies.put(TournamentFightType.valueOf(st.nextToken()), rs.getInt("value"));
+							}
+							break;
+						case "Kills":
+							if (st.hasMoreTokens())
+							{
+								tournamentKills.put(TournamentFightType.valueOf(st.nextToken()), rs.getInt("value"));
+							}
+							break;
+						
+						case "Damage":
+							if (st.hasMoreTokens())
+							{
+								tournamentDamage.put(TournamentFightType.valueOf(st.nextToken()), rs.getInt("value"));
+							}
+							break;
+						
+					}
+					
+				}
+				
+			}
+			
+			con.close();
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+		
+		showPlayerTournamentData(player, targetObjectId, type, tournamentKills, tournamentVictories, tournamentDefeats, tournamentTies, tournamentDamage);
+	}
+	
+	class WDTRecord
+	{
+		String playerName;
+		
+	}
+	
+	public void storeTournamentData(Player player)
+	{
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentVictories().entrySet())
+		{
+			PlayerVariables.setVar(player, "Tournament-Victories-" + entry.getKey().name(), entry.getValue(), -1);
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentDefeats().entrySet())
+		{
+			PlayerVariables.setVar(player, "Tournament-Defeats-" + entry.getKey().name(), entry.getValue(), -1);
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentTies().entrySet())
+		{
+			PlayerVariables.setVar(player, "Tournament-Ties-" + entry.getKey().name(), entry.getValue(), -1);
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentKills().entrySet())
+		{
+			PlayerVariables.setVar(player, "Tournament-Kills-" + entry.getKey().name(), entry.getValue(), -1);
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentDamage().entrySet())
+		{
+			PlayerVariables.setVar(player, "Tournament-Damage-" + entry.getKey().name(), entry.getValue(), -1);
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentDamage().entrySet())
+		{
+			PlayerVariables.setVar(player, "Tournament-WDT-" + entry.getKey().name(), String.valueOf(getWinDefeatTie(player, entry.getKey())), -1);
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentDamage().entrySet())
+		{
+			PlayerVariables.setVar(player, "Tournament-DPF-" + entry.getKey().name(), String.valueOf(getDamagePerFight(player, entry.getKey())), -1);
+		}
+		
+		PlayerVariables.setVar(player, "Tournament-Points", player.getTournamentPoints(), -1);
+		
+	}
+	
+	/**
+	 * @return the started
+	 */
+	public boolean isRunning()
+	{
+		return running;
+	}
+	
+	/**
+	 * @param started the started to set
+	 */
+	public void setRunning(boolean started)
+	{
+		this.running = started;
+	}
+	
+	/**
+	 * @return the finishEvent
+	 */
+	public ScheduledFuture<?> getFinishEventTask()
+	{
+		return finishEventTask;
+	}
+	
+	/**
+	 * @param finishEvent the finishEvent to set
+	 */
+	public void setFinishEventTask(ScheduledFuture<?> finishEvent)
+	{
+		this.finishEventTask = finishEvent;
+	}
+	
+	/**
+	 * @return the tournamentTeleporting
+	 */
+	public boolean isTournamentTeleporting()
+	{
+		return tournamentTeleporting;
+	}
+	
+	/**
+	 * @param tournamentTeleporting the tournamentTeleporting to set
+	 */
+	public void setTournamentTeleporting(boolean tournamentTeleporting)
+	{
+		this.tournamentTeleporting = tournamentTeleporting;
+	}
+	
+	public double getDamagePerFight(int totalDamage, int totalFightsDone)
+	{
+		double dpf = 0;
+		if (totalFightsDone == 0)
+		{
+			return 0;
+		}
+		dpf = (totalDamage / totalFightsDone * 1000);
+		return dpf;
+	}
+	
+	public int getDamagePerFight(Player player, TournamentFightType type)
+	{
+		int dpf = 0;
+		int totalDamage = player.getTournamentTotalDamage();
+		int totalFightsDone = player.getTournamentFightsDone(type);
+		if (totalFightsDone == 0)
+		{
+			return 0;
+		}
+		dpf = (totalDamage / totalFightsDone);
+		return dpf;
+	}
+	
+	public double getWinDefeatTie(int totalFightsDone, int totalVictories, int totalDefeats, int totalTies)
+	{
+		int ratioByFight = 1;
+		double playerWDT = 0;
+		if (totalFightsDone == 0)
+		{
+			return 0;
+		}
+		playerWDT = ratioByFight * (((3) * totalVictories) + ((-3) * totalDefeats) + (totalTies)) / totalFightsDone;
+		return playerWDT;
+	}
+	
+	public double getDamagePerFight(Player player)
+	{
+		double dpf = 0;
+		int totalDamage = player.getTournamentTotalDamage();
+		int totalFightsDone = player.getTotalTournamentFightsDone();
+		if (totalFightsDone == 0)
+		{
+			return 0;
+		}
+		dpf = (totalDamage / totalFightsDone);
+		return dpf;
+	}
+	
+	public double getWinDefeatTie(Player player)
+	{
+		int ratioByFight = 1;
+		double playerWDT = 0;
+		int totalFightsDone = player.getTotalTournamentFightsDone();
+		int totalVictories = player.getTotalVictories();
+		int totalDefeats = player.getTotalDefeats();
+		int totalTies = player.getTotalTies();
+		if (totalFightsDone == 0)
+		{
+			return 0;
+		}
+		playerWDT = ratioByFight * (((3) * totalVictories) + ((-3) * totalDefeats) + (totalTies)) / totalFightsDone;
+		return playerWDT;
+	}
+	
+	public double getWinDefeatTie(Player player, TournamentFightType type)
+	{
+		int ratioByFight = 1;
+		double playerWDT = 0;
+		int totalFightsDone = player.getTournamentFightsDone(type);
+		int totalVictories = player.getTournamentVictories().get(type);
+		int totalDefeats = player.getTournamentDefeats().get(type);
+		int totalTies = player.getTournamentTies().get(type);
+		if (totalFightsDone == 0)
+		{
+			return 0;
+		}
+		playerWDT = ratioByFight * (((3) * totalVictories) + ((-3) * totalDefeats) + (totalTies)) / totalFightsDone;
+		return playerWDT;
+	}
+	
+	// RANKING
+	class TourRankRecord
+	{
+		int pos;
+		String playerName;
+		String recordVal;
+		
+		public TourRankRecord(int pos, String playerName, String recordVal)
+		{
+			this.pos = pos + 1;
+			this.playerName = playerName;
+			this.recordVal = recordVal;
+		}
+	}
+	
+	public String generateRankingRecords(Player player, TournamentFightType type, LinkedList<TourRankRecord> records, String rankType)
+	{
+		StringBuilder sb = new StringBuilder();
+		int bgColor = 1;
+		for (TourRankRecord record : records)
+		{
+			if (record == null)
+				continue;
+			if (bgColor % 2 == 0)
+				sb.append("<table width=300 bgcolor=000000>");
+			else
+				sb.append("<table width=300>");
+			sb.append("<tr>");
+			sb.append("<td align=center fixwidth=20>");
+			sb.append(record.pos);
+			sb.append("</td>");
+			sb.append("<td fixwidth=5></td>");
+			sb.append("<td align=center fixwidth=75>");
+			sb.append(record.playerName);
+			sb.append("</td>");
+			sb.append("<td align=center fixwidth=50>");
+			sb.append(record.recordVal);
+			sb.append("</td>");
+			sb.append("<td align=center fixwidth=50>");
+			sb.append("<a action=\"bypass bp_checkTournamentPlayer " + record.playerName + " " + type.name() + "\"><font color=LEVEL>Check</font></a>");
+			sb.append("</td>");
+			sb.append("</tr>");
+			sb.append("</table>");
+			
+		}
+		return sb.toString();
+	}
+	
+	public void showRanking(Player player, TournamentFightType fightType, String rankType)
+	{
+		NpcHtmlMessage htm = new NpcHtmlMessage(0);
+		htm.setFile("data/html/mods/tournament/ranking/" + rankType + "/" + fightType.name() + ".htm");
+		
+		LinkedList<TourRankRecord> records = new LinkedList<>();
+		int pos = 0;
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("SELECT * FROM tournament_player_data WHERE fight_type=? ORDER BY " + rankType + " DESC LIMIT 10");
+			offline.setString(1, fightType.name());
+			rs = offline.executeQuery();
+			while (rs.next())
+			{
+				
+				records.add(new TourRankRecord(pos, PlayerInfoTable.getInstance().getPlayerName(rs.getInt("obj_id")), String.valueOf(rs.getInt(rankType))));
+				pos++;
+				
+			}
+			
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+		for (Map.Entry<TournamentFightType, Integer> entry : player.getTournamentVictories().entrySet())
+			htm.replace("%ranking-" + rankType + entry.getKey() + "%", generateRankingRecords(player, fightType, records, rankType));
+		player.sendPacket(htm);
+	}
+	
+	/**
+	 * @return the allTimeFights
+	 */
+	public int getAllTimeFights()
+	{
+		return allTimeFights;
+	}
+	
+	/**
+	 * @param allTimeFights the allTimeFights to set
+	 */
+	public void setAllTimeFights(int allTimeFights)
+	{
+		this.allTimeFights = allTimeFights;
+	}
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/enums/TournamentFightType.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/enums/TournamentFightType.java
new file mode 100644
index 0000000..fd42894
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/enums/TournamentFightType.java
@@ -0,0 +1,16 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.enums;
+
+/**
+ * @author Rouxy
+ */
+public enum TournamentFightType
+{
+	NONE,
+	F1X1,
+	F2X2,
+	F3X3,
+	F4X4,
+	F5X5,
+	F9X9;
+
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch.java
new file mode 100644
index 0000000..bb5beef
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch.java
@@ -0,0 +1,16 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.matches;
+
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+
+/**
+ * @author Rouxy
+ */
+public abstract class TournamentMatch
+{
+	public abstract boolean register(TournamentTeam team);
+	
+	public abstract boolean unRegister(TournamentTeam team);
+	
+	public abstract boolean checkConditions(TournamentTeam team);
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch1x1.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch1x1.java
new file mode 100644
index 0000000..56f1421
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch1x1.java
@@ -0,0 +1,185 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.matches;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ScheduledFuture;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.enums.actors.ClassId;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+
+/**
+ * @author Rouxy
+ */
+public class TournamentMatch1x1 extends TournamentMatch
+{
+	private List<TournamentTeam> registeredTeams = new ArrayList<>();
+	private ScheduledFuture<?> searchFightsTask = null;
+	private final TournamentFightType fightType = TournamentFightType.F1X1;
+	
+	public static TournamentMatch1x1 getInstance()
+	{
+		return SingleTonHolder._instance;
+	}
+	
+	private static class SingleTonHolder
+	{
+		protected static TournamentMatch1x1 _instance = new TournamentMatch1x1();
+	}
+	
+	@Override
+	public boolean register(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().put(team, TournamentFightType.F1X1);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	@Override
+	public boolean unRegister(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().remove(team);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	public ScheduledFuture<?> getSearchFightsTask()
+	{
+		return searchFightsTask;
+	}
+	
+	public void setSearchFightsTask(ScheduledFuture<?> searchFightsTask)
+	{
+		this.searchFightsTask = searchFightsTask;
+	}
+	
+	public List<TournamentTeam> getRegisteredTeams()
+	{
+		return registeredTeams;
+	}
+	
+	public void setRegisteredTeams(List<TournamentTeam> registeredTeams)
+	{
+		this.registeredTeams = registeredTeams;
+	}
+	
+	@Override
+	public boolean checkConditions(TournamentTeam team)
+	{
+		
+		if (team.getMembers().size() != 1)
+		{
+			team.sendMessage("Only 1 player allowed in this mode.");
+			team.screenMessage("Only 1 player allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DUELIST) > Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F1X1) + " Duelist(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F1X1) + " Duelist(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.ARCHMAGE) > Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F1X1) + " Archmage(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F1X1) + " Archmage(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.SOULTAKER) > Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F1X1) + " Soultaker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F1X1) + " Soultaker(s) are allowed in this mode.");
+			return false;
+		}
+		
+		if (team.getCountOfClass(ClassId.STORM_SCREAMER) > Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F1X1) + " Storm Screamer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F1X1) + " Storm Screamer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.MYSTIC_MUSE) > Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F1X1) + " Mystic Muse(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F1X1) + " Mystic Muse(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.TITAN) > Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F1X1) + " Titan(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F1X1) + " Titan(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOMINATOR) > Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F1X1) + " Dominator(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F1X1) + " Dominator(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F1X1) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F1X1) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F1X1) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F1X1) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getArchersCount() > Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F1X1) + " Archer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F1X1) + " Archer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getTankersCount() > Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F1X1) + " Tanker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F1X1) + " Tanker(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getHealersCount() > Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F1X1) + " Healer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F1X1) + " Healer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getDaggersCount() > Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F1X1))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F1X1) + " Dagger(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F1X1) + " Dagger(s) are allowed in this mode.");
+			return false;
+		}
+		
+		return true;
+	}
+	
+	/**
+	 * @return the fightType
+	 */
+	public TournamentFightType getFightType()
+	{
+		return fightType;
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch2x2.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch2x2.java
new file mode 100644
index 0000000..422e7cb
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch2x2.java
@@ -0,0 +1,185 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.matches;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ScheduledFuture;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.enums.actors.ClassId;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+
+/**
+ * @author Rouxy
+ */
+public class TournamentMatch2x2 extends TournamentMatch
+{
+	private List<TournamentTeam> registeredTeams = new ArrayList<>();
+	private ScheduledFuture<?> searchFightsTask = null;
+	private final TournamentFightType fightType = TournamentFightType.F2X2;
+	
+	public static TournamentMatch2x2 getInstance()
+	{
+		return SingleTonHolder._instance;
+	}
+	
+	private static class SingleTonHolder
+	{
+		protected static TournamentMatch2x2 _instance = new TournamentMatch2x2();
+	}
+	
+	@Override
+	public boolean register(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().put(team, TournamentFightType.F2X2);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	@Override
+	public boolean unRegister(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().remove(team);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	public ScheduledFuture<?> getSearchFightsTask()
+	{
+		return searchFightsTask;
+	}
+	
+	public void setSearchFightsTask(ScheduledFuture<?> searchFightsTask)
+	{
+		this.searchFightsTask = searchFightsTask;
+	}
+	
+	public List<TournamentTeam> getRegisteredTeams()
+	{
+		return registeredTeams;
+	}
+	
+	public void setRegisteredTeams(List<TournamentTeam> registeredTeams)
+	{
+		this.registeredTeams = registeredTeams;
+	}
+	
+	@Override
+	public boolean checkConditions(TournamentTeam team)
+	{
+		
+		if (team.getMembers().size() != 2)
+		{
+			team.sendMessage("Your team must contains 2 players.");
+			team.screenMessage("Your team must contains 2 players.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DUELIST) > Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F2X2) + " Duelist(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F2X2) + " Duelist(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.ARCHMAGE) > Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F2X2) + " Archmage(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F2X2) + " Archmage(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.SOULTAKER) > Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F2X2) + " Soultaker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F2X2) + " Soultaker(s) are allowed in this mode.");
+			return false;
+		}
+		
+		if (team.getCountOfClass(ClassId.STORM_SCREAMER) > Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F2X2) + " Storm Screamer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F2X2) + " Storm Screamer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.MYSTIC_MUSE) > Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F2X2) + " Mystic Muse(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F2X2) + " Mystic Muse(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.TITAN) > Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F2X2) + " Titan(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F2X2) + " Titan(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOMINATOR) > Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F2X2) + " Dominator(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F2X2) + " Dominator(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F2X2) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F2X2) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F2X2) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F2X2) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getArchersCount() > Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F2X2) + " Archer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F2X2) + " Archer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getTankersCount() > Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F2X2) + " Tanker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F2X2) + " Tanker(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getHealersCount() > Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F2X2) + " Healer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F2X2) + " Healer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getDaggersCount() > Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F2X2))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F2X2) + " Dagger(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F2X2) + " Dagger(s) are allowed in this mode.");
+			return false;
+		}
+		
+		return true;
+	}
+	
+	/**
+	 * @return the fightType
+	 */
+	public TournamentFightType getFightType()
+	{
+		return fightType;
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch3x3.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch3x3.java
new file mode 100644
index 0000000..5ff5a8d
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch3x3.java
@@ -0,0 +1,185 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.matches;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ScheduledFuture;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.enums.actors.ClassId;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+
+/**
+ * @author Rouxy
+ */
+public class TournamentMatch3x3 extends TournamentMatch
+{
+	private List<TournamentTeam> registeredTeams = new ArrayList<>();
+	private ScheduledFuture<?> searchFightsTask = null;
+	private final TournamentFightType fightType = TournamentFightType.F3X3;
+	
+	public static TournamentMatch3x3 getInstance()
+	{
+		return SingleTonHolder._instance;
+	}
+	
+	private static class SingleTonHolder
+	{
+		protected static TournamentMatch3x3 _instance = new TournamentMatch3x3();
+	}
+	
+	@Override
+	public boolean register(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().put(team, TournamentFightType.F3X3);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	@Override
+	public boolean unRegister(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().remove(team);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	public ScheduledFuture<?> getSearchFightsTask()
+	{
+		return searchFightsTask;
+	}
+	
+	public void setSearchFightsTask(ScheduledFuture<?> searchFightsTask)
+	{
+		this.searchFightsTask = searchFightsTask;
+	}
+	
+	public List<TournamentTeam> getRegisteredTeams()
+	{
+		return registeredTeams;
+	}
+	
+	public void setRegisteredTeams(List<TournamentTeam> registeredTeams)
+	{
+		this.registeredTeams = registeredTeams;
+	}
+	
+	@Override
+	public boolean checkConditions(TournamentTeam team)
+	{
+		
+		if (team.getMembers().size() != 3)
+		{
+			team.sendMessage("Your team must contains 3 players.");
+			team.screenMessage("Your team must contains 3 players.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DUELIST) > Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F3X3) + " Duelist(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F3X3) + " Duelist(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.ARCHMAGE) > Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F3X3) + " Archmage(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F3X3) + " Archmage(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.SOULTAKER) > Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F3X3) + " Soultaker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F3X3) + " Soultaker(s) are allowed in this mode.");
+			return false;
+		}
+		
+		if (team.getCountOfClass(ClassId.STORM_SCREAMER) > Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F3X3) + " Storm Screamer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F3X3) + " Storm Screamer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.MYSTIC_MUSE) > Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F3X3) + " Mystic Muse(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F3X3) + " Mystic Muse(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.TITAN) > Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F3X3) + " Titan(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F3X3) + " Titan(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOMINATOR) > Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F3X3) + " Dominator(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F3X3) + " Dominator(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F3X3) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F3X3) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F3X3) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F3X3) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getArchersCount() > Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F3X3) + " Archer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F3X3) + " Archer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getTankersCount() > Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F3X3) + " Tanker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F3X3) + " Tanker(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getHealersCount() > Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F3X3) + " Healer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F3X3) + " Healer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getDaggersCount() > Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F3X3))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F3X3) + " Dagger(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F3X3) + " Dagger(s) are allowed in this mode.");
+			return false;
+		}
+		
+		return true;
+	}
+	
+	/**
+	 * @return the fightType
+	 */
+	public TournamentFightType getFightType()
+	{
+		return fightType;
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch4x4.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch4x4.java
new file mode 100644
index 0000000..2c3089c
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch4x4.java
@@ -0,0 +1,185 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.matches;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ScheduledFuture;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.enums.actors.ClassId;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+
+/**
+ * @author Rouxy
+ */
+public class TournamentMatch4x4 extends TournamentMatch
+{
+	private List<TournamentTeam> registeredTeams = new ArrayList<>();
+	private ScheduledFuture<?> searchFightsTask = null;
+	private final TournamentFightType fightType = TournamentFightType.F4X4;
+	
+	public static TournamentMatch4x4 getInstance()
+	{
+		return SingleTonHolder._instance;
+	}
+	
+	private static class SingleTonHolder
+	{
+		protected static TournamentMatch4x4 _instance = new TournamentMatch4x4();
+	}
+	
+	@Override
+	public boolean register(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().put(team, TournamentFightType.F4X4);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	@Override
+	public boolean unRegister(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().remove(team);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	public ScheduledFuture<?> getSearchFightsTask()
+	{
+		return searchFightsTask;
+	}
+	
+	public void setSearchFightsTask(ScheduledFuture<?> searchFightsTask)
+	{
+		this.searchFightsTask = searchFightsTask;
+	}
+	
+	public List<TournamentTeam> getRegisteredTeams()
+	{
+		return registeredTeams;
+	}
+	
+	public void setRegisteredTeams(List<TournamentTeam> registeredTeams)
+	{
+		this.registeredTeams = registeredTeams;
+	}
+	
+	@Override
+	public boolean checkConditions(TournamentTeam team)
+	{
+		
+		if (team.getMembers().size() != 4)
+		{
+			team.sendMessage("Your team must contains 4 players.");
+			team.screenMessage("Your team must contains 4 players.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DUELIST) > Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F4X4) + " Duelist(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F4X4) + " Duelist(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.ARCHMAGE) > Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F4X4) + " Archmage(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F4X4) + " Archmage(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.SOULTAKER) > Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F4X4) + " Soultaker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F4X4) + " Soultaker(s) are allowed in this mode.");
+			return false;
+		}
+		
+		if (team.getCountOfClass(ClassId.STORM_SCREAMER) > Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F4X4) + " Storm Screamer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F4X4) + " Storm Screamer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.MYSTIC_MUSE) > Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F4X4) + " Mystic Muse(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F4X4) + " Mystic Muse(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.TITAN) > Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F4X4) + " Titan(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F4X4) + " Titan(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOMINATOR) > Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F4X4) + " Dominator(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F4X4) + " Dominator(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F4X4) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F4X4) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F4X4) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F4X4) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getArchersCount() > Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F4X4) + " Archer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F4X4) + " Archer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getTankersCount() > Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F4X4) + " Tanker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F4X4) + " Tanker(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getHealersCount() > Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F4X4) + " Healer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F4X4) + " Healer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getDaggersCount() > Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F4X4))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F4X4) + " Dagger(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F4X4) + " Dagger(s) are allowed in this mode.");
+			return false;
+		}
+		
+		return true;
+	}
+	
+	/**
+	 * @return the fightType
+	 */
+	public TournamentFightType getFightType()
+	{
+		return fightType;
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch5x5.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch5x5.java
new file mode 100644
index 0000000..9f400bd
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch5x5.java
@@ -0,0 +1,185 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.matches;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ScheduledFuture;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.enums.actors.ClassId;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+
+/**
+ * @author Rouxy
+ */
+public class TournamentMatch5x5 extends TournamentMatch
+{
+	private List<TournamentTeam> registeredTeams = new ArrayList<>();
+	private ScheduledFuture<?> searchFightsTask = null;
+	private final TournamentFightType fightType = TournamentFightType.F5X5;
+	
+	public static TournamentMatch5x5 getInstance()
+	{
+		return SingleTonHolder._instance;
+	}
+	
+	private static class SingleTonHolder
+	{
+		protected static TournamentMatch5x5 _instance = new TournamentMatch5x5();
+	}
+	
+	@Override
+	public boolean register(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().put(team, TournamentFightType.F5X5);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	@Override
+	public boolean unRegister(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().remove(team);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	public ScheduledFuture<?> getSearchFightsTask()
+	{
+		return searchFightsTask;
+	}
+	
+	public void setSearchFightsTask(ScheduledFuture<?> searchFightsTask)
+	{
+		this.searchFightsTask = searchFightsTask;
+	}
+	
+	public List<TournamentTeam> getRegisteredTeams()
+	{
+		return registeredTeams;
+	}
+	
+	public void setRegisteredTeams(List<TournamentTeam> registeredTeams)
+	{
+		this.registeredTeams = registeredTeams;
+	}
+	
+	@Override
+	public boolean checkConditions(TournamentTeam team)
+	{
+		
+		if (team.getMembers().size() != 5)
+		{
+			team.sendMessage("Your team must contains 5 players.");
+			team.screenMessage("Your team must contains 5 players.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DUELIST) > Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F5X5) + " Duelist(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F5X5) + " Duelist(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.ARCHMAGE) > Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F5X5) + " Archmage(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F5X5) + " Archmage(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.SOULTAKER) > Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F5X5) + " Soultaker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F5X5) + " Soultaker(s) are allowed in this mode.");
+			return false;
+		}
+		
+		if (team.getCountOfClass(ClassId.STORM_SCREAMER) > Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F5X5) + " Storm Screamer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F5X5) + " Storm Screamer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.MYSTIC_MUSE) > Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F5X5) + " Mystic Muse(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F5X5) + " Mystic Muse(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.TITAN) > Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F5X5) + " Titan(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F5X5) + " Titan(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOMINATOR) > Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F5X5) + " Dominator(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F5X5) + " Dominator(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F5X5) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F5X5) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F5X5) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F5X5) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getArchersCount() > Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F5X5) + " Archer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F5X5) + " Archer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getTankersCount() > Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F5X5) + " Tanker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F5X5) + " Tanker(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getHealersCount() > Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F5X5) + " Healer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F5X5) + " Healer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getDaggersCount() > Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F5X5))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F5X5) + " Dagger(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F5X5) + " Dagger(s) are allowed in this mode.");
+			return false;
+		}
+		
+		return true;
+	}
+	
+	/**
+	 * @return the fightType
+	 */
+	public TournamentFightType getFightType()
+	{
+		return fightType;
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch9x9.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch9x9.java
new file mode 100644
index 0000000..1317628
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/matches/TournamentMatch9x9.java
@@ -0,0 +1,185 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.matches;
+
+import java.util.ArrayList;
+import java.util.List;
+import java.util.concurrent.ScheduledFuture;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.enums.actors.ClassId;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+
+/**
+ * @author Rouxy
+ */
+public class TournamentMatch9x9 extends TournamentMatch
+{
+	private List<TournamentTeam> registeredTeams = new ArrayList<>();
+	private ScheduledFuture<?> searchFightsTask = null;
+	private final TournamentFightType fightType = TournamentFightType.F9X9;
+	
+	public static TournamentMatch9x9 getInstance()
+	{
+		return SingleTonHolder._instance;
+	}
+	
+	private static class SingleTonHolder
+	{
+		protected static TournamentMatch9x9 _instance = new TournamentMatch9x9();
+	}
+	
+	@Override
+	public boolean register(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().put(team, TournamentFightType.F9X9);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	@Override
+	public boolean unRegister(TournamentTeam team)
+	{
+		try
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().remove(team);
+			return true;
+		}
+		catch (Exception e)
+		{
+			
+			e.printStackTrace();
+			return false;
+		}
+	}
+	
+	public ScheduledFuture<?> getSearchFightsTask()
+	{
+		return searchFightsTask;
+	}
+	
+	public void setSearchFightsTask(ScheduledFuture<?> searchFightsTask)
+	{
+		this.searchFightsTask = searchFightsTask;
+	}
+	
+	public List<TournamentTeam> getRegisteredTeams()
+	{
+		return registeredTeams;
+	}
+	
+	public void setRegisteredTeams(List<TournamentTeam> registeredTeams)
+	{
+		this.registeredTeams = registeredTeams;
+	}
+	
+	@Override
+	public boolean checkConditions(TournamentTeam team)
+	{
+		
+		if (team.getMembers().size() != 9)
+		{
+			team.sendMessage("Your team must contains 9 players.");
+			team.screenMessage("Your team must contains 9 players.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DUELIST) > Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F9X9) + " Duelist(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DUELIST_ALLOWED.get(TournamentFightType.F9X9) + " Duelist(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.ARCHMAGE) > Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F9X9) + " Archmage(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHMAGE_ALLOWED.get(TournamentFightType.F9X9) + " Archmage(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.SOULTAKER) > Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F9X9) + " Soultaker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_SOULTAKER_ALLOWED.get(TournamentFightType.F9X9) + " Soultaker(s) are allowed in this mode.");
+			return false;
+		}
+		
+		if (team.getCountOfClass(ClassId.STORM_SCREAMER) > Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F9X9) + " Storm Screamer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_STORMSCREAMER_ALLOWED.get(TournamentFightType.F9X9) + " Storm Screamer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.MYSTIC_MUSE) > Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F9X9) + " Mystic Muse(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_MYSTICMUSE_ALLOWED.get(TournamentFightType.F9X9) + " Mystic Muse(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.TITAN) > Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F9X9) + " Titan(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TITAN_ALLOWED.get(TournamentFightType.F9X9) + " Titan(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOMINATOR) > Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F9X9) + " Dominator(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOMINATOR_ALLOWED.get(TournamentFightType.F9X9) + " Dominator(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F9X9) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F9X9) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getCountOfClass(ClassId.DOOMCRYER) > Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F9X9) + " Doomcryer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DOOMCRYER_ALLOWED.get(TournamentFightType.F9X9) + " Doomcryer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getArchersCount() > Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F9X9) + " Archer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_ARCHER_ALLOWED.get(TournamentFightType.F9X9) + " Archer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getTankersCount() > Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F9X9) + " Tanker(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_TANKER_ALLOWED.get(TournamentFightType.F9X9) + " Tanker(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getHealersCount() > Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F9X9) + " Healer(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_HEALER_ALLOWED.get(TournamentFightType.F9X9) + " Healer(s) are allowed in this mode.");
+			return false;
+		}
+		if (team.getDaggersCount() > Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F9X9))
+		{
+			team.sendMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F9X9) + " Dagger(s) are allowed in this mode.");
+			team.screenMessage("Only " + Config.TOURNAMENT_DAGGER_ALLOWED.get(TournamentFightType.F9X9) + " Dagger(s) are allowed in this mode.");
+			return false;
+		}
+		
+		return true;
+	}
+	
+	/**
+	 * @return the fightType
+	 */
+	public TournamentFightType getFightType()
+	{
+		return fightType;
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/model/TournamentArena.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/model/TournamentArena.java
new file mode 100644
index 0000000..ab21cae
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/model/TournamentArena.java
@@ -0,0 +1,76 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.model;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.sf.l2j.commons.data.StatSet;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.location.Location;
+
+/**
+ * @author Rouxy
+ */
+
+public class TournamentArena
+{
+	private final int id;
+	private List<Location> teamOneLocation = new ArrayList<>();
+	private List<Location> teamTwoLocation = new ArrayList<>();
+	private int time;
+	
+	private final List<TournamentFightType> types = new ArrayList<>();
+	
+	public TournamentArena(StatSet set, List<Location> teamOneLocation, List<Location> teamTwoLocation)
+	{
+		String fTypes = set.getString("types");
+		for (String type : fTypes.split(";"))
+		{
+			if (TournamentFightType.valueOf(type) != null)
+				types.add(TournamentFightType.valueOf(type));
+		}
+		id = set.getInteger("id");
+		this.teamOneLocation = teamOneLocation;
+		this.teamTwoLocation = teamTwoLocation;
+	}
+	
+	public List<Location> getTeamOneLocation()
+	{
+		return teamOneLocation;
+	}
+	
+	public void setTeamOneLocation(List<Location> teamOneLocation)
+	{
+		this.teamOneLocation = teamOneLocation;
+	}
+	
+	public List<Location> getTeamTwoLocation()
+	{
+		return teamTwoLocation;
+	}
+	
+	public void setTeamTwoLocation(List<Location> teamTwoLocation)
+	{
+		this.teamTwoLocation = teamTwoLocation;
+	}
+	
+	public int getTime()
+	{
+		return time;
+	}
+	
+	public void setTime(int time)
+	{
+		this.time = time;
+	}
+	
+	public int getId()
+	{
+		return id;
+	}
+	
+	public List<TournamentFightType> getTypes()
+	{
+		return types;
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/model/TournamentTeam.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/model/TournamentTeam.java
new file mode 100644
index 0000000..06b0253
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/model/TournamentTeam.java
@@ -0,0 +1,455 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.model;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.enums.LootRule;
+import net.sf.l2j.gameserver.enums.MessageType;
+import net.sf.l2j.gameserver.enums.actors.ClassId;
+import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.instance.InstanceManager;
+import net.sf.l2j.gameserver.model.group.Party;
+import net.sf.l2j.gameserver.network.serverpackets.ExShowScreenMessage;
+import net.sf.l2j.util.RewardHolder;
+
+/**
+ * @author Rouxy
+ */
+public class TournamentTeam
+{
+	private Player leader;
+	private Player target;
+	private List<Player> members = new ArrayList<>();
+	private Party party;
+	private int teamFightId;
+	
+	public TournamentTeam(Player leader, Player target)
+	{
+		this.leader = leader;
+		this.target = target;
+		
+		members.add(0, leader);
+		leader.setTournamentTeam(this);
+		leader.sendMessage("Your Tournament fight has been created.");
+		
+		if (target != null)
+		{
+			leader.sendMessage(target.getName() + " entered your Tournament Team.");
+			target.sendMessage(leader.getName() + " entered your Tournament Team.");
+			members.add(1, target);
+			target.setTournamentTeam(this);
+			
+		}
+		
+	}
+	
+	public List<Player> getMembers()
+	{
+		return members;
+	}
+	
+	public void setMembers(List<Player> members)
+	{
+		this.members = members;
+	}
+	
+	public Player getLeader()
+	{
+		return leader;
+	}
+	
+	public void setLeader(Player leader)
+	{
+		this.leader = leader;
+	}
+	
+	public Player getTarget()
+	{
+		return target;
+	}
+	
+	public void setTarget(Player target)
+	{
+		this.target = target;
+	}
+	
+	public void sendMessage(String text)
+	{
+		for (Player player : getMembers())
+		{
+			
+			player.sendMessage("[Tournament]: " + text);
+			
+		}
+	}
+	
+	public void screenMessage(String text)
+	{
+		for (Player player : getMembers())
+		{
+			
+			player.sendPacket(new ExShowScreenMessage("[Tournament]: " + text, 4000));
+			
+		}
+	}
+	
+	public String getName()
+	{
+		return leader.getName() + "'s Team";
+	}
+	
+	public void addMember(Player player)
+	{
+		if (player == null || getMembers().contains(player))
+			return;
+		
+		getMembers().add(player);
+		player.setTournamentTeam(this);
+		player.sendMessage("You entered " + leader.getName() + "'s Tournament Team.");
+		sendMessage("Player " + player.getName() + " joined your Tournament Team.");
+		
+	}
+	
+	public Party getParty()
+	{
+		return party;
+	}
+	
+	public void setParty(Party party)
+	{
+		this.party = party;
+	}
+	
+	public int getCountOfClass(ClassId classId)
+	{
+		int count = 0;
+		for (Player player : getMembers())
+		{
+			if (player.getClassId() == classId)
+			{
+				count++;
+			}
+		}
+		return count;
+	}
+	
+	public int getHealersCount()
+	{
+		int count = 0;
+		for (Player player : getMembers())
+		{
+			if (player.getClassId().isHealer())
+			{
+				count++;
+			}
+		}
+		return count;
+		
+	}
+	
+	public int getTankersCount()
+	{
+		int count = 0;
+		for (Player player : getMembers())
+		{
+			if (player.getClassId().isTanker())
+			{
+				count++;
+			}
+		}
+		return count;
+		
+	}
+	
+	public int getDaggersCount()
+	{
+		int count = 0;
+		for (Player player : getMembers())
+		{
+			if (player.getClassId().isDagger())
+			{
+				count++;
+			}
+		}
+		return count;
+		
+	}
+	
+	public int getArchersCount()
+	{
+		int count = 0;
+		for (Player player : getMembers())
+		{
+			if (player.getClassId().isArcher())
+			{
+				count++;
+			}
+		}
+		return count;
+		
+	}
+	
+	public void setInTournamentMatch(boolean val)
+	{
+		for (Player player : getMembers())
+		{
+			player.setInTournamentMatch(val);
+		}
+	}
+	
+	public void setFightId(int id)
+	{
+		for (Player player : getMembers())
+		{
+			player.setTournamentFightId(id);
+		}
+		teamFightId = id;
+	}
+	
+	public void paralyze()
+	{
+		for (Player player : getMembers())
+		{
+			player.setTarget(null);
+			player.setInvul(true);
+			player.setIsParalyzed(true);
+			player.broadcastUserInfo();
+		}
+	}
+	
+	public void unparalyze()
+	{
+		for (Player player : getMembers())
+		{
+			player.setTarget(null);
+			player.setInvul(false);
+			player.setIsParalyzed(false);
+			player.broadcastUserInfo();
+			
+		}
+	}
+	
+	public boolean teamIsDefeated()
+	{
+		for (Player player : getMembers())
+		{
+			if (!player.isDead())
+			{
+				return false;
+			}
+		}
+		return true;
+	}
+	
+	public int getAliveMembers()
+	{
+		int count = 0;
+		for (Player player : getMembers())
+		{
+			if (player.isDead())
+				continue;
+			else
+				count++;
+		}
+		return count;
+	}
+	
+	public void reward(boolean winner)
+	{
+		String text = winner ? "Your team have won the Tournament Battle! =D" : "Your team lost won the Tournament Battle! =(";
+		screenMessage(text);
+		sendMessage(text);
+		for (Player player : getMembers())
+		{
+			
+			for (RewardHolder reward : winner ? Config.TOURNAMENT_FIGHT_REWARD_WINNER : Config.TOURNAMENT_FIGHT_REWARD_LOOSER)
+			{
+				player.addItem("TournamentReward", reward.getItemId(), reward.getCount(), player, true);
+			}
+		}
+		
+	}
+	
+	public void teleportBack()
+	{
+		for (Player player : getMembers())
+		{
+			player.teleportTo(player.getLastX(), player.getLastY(), player.getLastZ(), 0);
+		}
+	}
+	
+	public void removeTournamentTeam()
+	{
+		TournamentManager.getInstance().getRegisteredTournamentTeams().remove(this);
+	}
+	
+	public void setTournamentFightType(TournamentFightType type)
+	{
+		for (Player player : getMembers())
+		{
+			player.setTournamentFightType(type);
+		}
+	}
+	
+	public void removeMember(Player member)
+	{
+		
+		if (!getMembers().contains(member))
+			return;
+		member.setTournamentFightId(0);
+		member.setTournamentFightType(TournamentFightType.NONE);
+		member.setTournamentTeam(null);
+		member.setTournamentTeamBeingInvited(false);
+		member.sendMessage("Your tournament Team has dispersed.");
+		if (party != null)
+			party.removePartyMember(member, MessageType.LEFT);
+		members.remove(member);
+		if (members.size() < 1)
+		{
+			disbandTeam();
+		}
+	}
+	
+	public void prepareToFight()
+	{
+		// first disband a possible old party
+		Party party = null;
+		for (Player player : getMembers())
+		{
+			if (player.isInParty())
+			{
+				player.getParty().disband();
+			}
+		}
+		if (getMembers().size() > 1)
+		{
+			party = new Party(leader, getMembers().get(1), LootRule.ITEM_LOOTER);
+		}
+		for (Player player : getMembers())
+		{
+			if (party != null && !player.isInParty())
+			{
+				party.addPartyMember(player);
+			}
+			// revive dead players
+			if (player.isDead())
+			{
+				player.doRevive();
+			}
+			// heal players
+			player.getStatus().setCpHpMp(player.getStatus().getMaxCp(), player.getStatus().getMaxHp(), player.getStatus().getMaxMp());
+			
+			// reset tournament match damages
+			player.setTournamentMatchDamage(0);
+		}
+		
+	}
+	
+	public void resetTeamMatchDamage()
+	{
+		for (Player player : getMembers())
+		{
+			player.setTournamentMatchDamage(0);
+		}
+	}
+	
+	public void backInstance()
+	{
+		for (Player player : getMembers())
+		{
+			player.setInstance(InstanceManager.getInstance().getInstance(0), true);
+			
+		}
+	}
+	
+	public void doRevive()
+	{
+		
+		for (Player player : getMembers())
+		{
+			
+			player.doRevive();
+			player.getStatus().setCpHpMp(player.getStatus().getMaxCp(), player.getStatus().getMaxHp(), player.getStatus().getMaxMp());
+		}
+	}
+	
+	public void disbandTeam()
+	{
+		if (TournamentManager.getInstance().getRegisteredTournamentTeams().containsKey(this))
+		{
+			TournamentManager.getInstance().getRegisteredTournamentTeams().remove(this);
+		}
+		for (Player member : getMembers())
+		{
+			member.setTournamentFightId(0);
+			member.setTournamentFightType(TournamentFightType.NONE);
+			member.setTournamentTeam(null);
+			member.setTournamentTeamBeingInvited(false);
+			member.sendMessage("Your tournament Team has dispersed.");
+		}
+		if (getParty() != null)
+			getParty().disband();
+		setParty(null);
+	}
+	
+	public int getFightId()
+	{
+		return teamFightId;
+	}
+	
+	public void setTeamFightId(int id)
+	{
+		teamFightId = id;
+	}
+	
+	public boolean isLeader(Player player)
+	{
+		return player == leader;
+	}
+	
+	public int getTotalDamage()
+	{
+		int damage = 0;
+		for (Player member : getMembers())
+		{
+			damage += member.getTournamentMatchDamage();
+		}
+		return damage;
+	}
+	
+	public void addTeamDefeat(TournamentFightType type)
+	{
+		for (Player member : getMembers())
+		{
+			member.addTournamentDefeat(type);
+		}
+	}
+	
+	public void addTeamVictory(TournamentFightType type)
+	{
+		for (Player member : getMembers())
+		{
+			member.addTournamentVictory(type);
+		}
+	}
+	
+	public void addTeamTie(TournamentFightType type)
+	{
+		for (Player member : getMembers())
+		{
+			member.addTournamentTie(type);
+		}
+	}
+	
+	public void addTotalDamageToPlayers(TournamentFightType type)
+	{
+		for (Player member : getMembers())
+		{
+			member.addTournamentDamage(type, member.getTournamentMatchDamage());
+		}
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/OutOfTheZoneTask.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/OutOfTheZoneTask.java
new file mode 100644
index 0000000..fefe122
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/OutOfTheZoneTask.java
@@ -0,0 +1,134 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.tasks;
+
+import net.sf.l2j.gameserver.enums.ZoneId;
+import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+
+/**
+ * @author Rouxy
+ */
+public class OutOfTheZoneTask implements Runnable
+{
+	private TournamentTeam teamOne;
+	private int teamOneOutSideTimes;
+	private TournamentTeam teamTwo;
+	private int teamTwoOutSideTimes;
+	
+	public OutOfTheZoneTask(TournamentTeam teamOne, TournamentTeam teamTwo)
+	{
+		this.teamOne = teamOne;
+		this.teamTwo = teamTwo;
+	}
+	
+	public boolean isOutOfTheZone(TournamentTeam team)
+	{
+		for (Player member : team.getMembers())
+		{
+			if (member == null)
+			{
+				return true;
+			}
+			if (!member.isInsideZone(ZoneId.TOURNAMENT))
+			{
+				team.sendMessage(member.getName() + " is out side of the zone. Return to zone or lose battle.");
+				return true;
+			}
+			
+		}
+		return false;
+	}
+	
+	@Override
+	public void run()
+	{
+		
+		if (teamOne.getFightId() != 0 && teamTwo.getFightId() != 0 && teamOne.getFightId() == teamTwo.getFightId())
+		{
+			TournamentFight fight = TournamentManager.getInstance().getCurrentFights().get(teamOne.getFightId());
+			if (fight != null && fight.isStarted())
+			{
+				if (isOutOfTheZone(teamOne))
+					teamOneOutSideTimes++;
+				else
+					teamOneOutSideTimes = 0;
+				if (isOutOfTheZone(teamTwo))
+					teamTwoOutSideTimes++;
+				else
+					teamTwoOutSideTimes = 0;
+				
+				if (teamOneOutSideTimes >= 10)
+					fight.finish(teamTwo);
+				if (teamTwoOutSideTimes >= 10)
+					fight.finish(teamOne);
+			}
+		}
+		
+	}
+	
+	/**
+	 * @return the teamOne
+	 */
+	public TournamentTeam getTeamOne()
+	{
+		return teamOne;
+	}
+	
+	/**
+	 * @param teamOne the teamOne to set
+	 */
+	public void setTeamOne(TournamentTeam teamOne)
+	{
+		this.teamOne = teamOne;
+	}
+	
+	/**
+	 * @return the teamTwo
+	 */
+	public TournamentTeam getTeamTwo()
+	{
+		return teamTwo;
+	}
+	
+	/**
+	 * @param teamTwo the teamTwo to set
+	 */
+	public void setTeamTwo(TournamentTeam teamTwo)
+	{
+		this.teamTwo = teamTwo;
+	}
+	
+	/**
+	 * @return the teamOneOutSideTimes
+	 */
+	public int getTeamOneOutSideTimes()
+	{
+		return teamOneOutSideTimes;
+	}
+	
+	/**
+	 * @param teamOneOutSideTimes the teamOneOutSideTimes to set
+	 */
+	public void setTeamOneOutSideTimes(int teamOneOutSideTimes)
+	{
+		this.teamOneOutSideTimes = teamOneOutSideTimes;
+	}
+	
+	/**
+	 * @return the teamTwoOutSideTimes
+	 */
+	public int getTeamTwoOutSideTimes()
+	{
+		return teamTwoOutSideTimes;
+	}
+	
+	/**
+	 * @param teamTwoOutSideTimes the teamTwoOutSideTimes to set
+	 */
+	public void setTeamTwoOutSideTimes(int teamTwoOutSideTimes)
+	{
+		this.teamTwoOutSideTimes = teamTwoOutSideTimes;
+	}
+	
+}
+
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/TournamentFight.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/TournamentFight.java
new file mode 100644
index 0000000..69639b8
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/TournamentFight.java
@@ -0,0 +1,439 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.tasks;
+
+import java.util.concurrent.ScheduledFuture;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.commons.pool.ThreadPool;
+import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentArena;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+import net.sf.l2j.gameserver.model.entity.instance.Instance;
+import net.sf.l2j.gameserver.network.serverpackets.ExShowScreenMessage;
+import net.sf.l2j.gameserver.network.serverpackets.ExShowScreenMessage.SMPOS;
+
+/**
+ * @author Zaun
+ */
+public class TournamentFight
+{
+	private TournamentFightType fightType = TournamentFightType.NONE;
+	private Instance instance = null;
+	
+	private TournamentArena tournamentArena;
+	private TournamentTeam teamOne;
+	private TournamentTeam teamTwo;
+	private int id;
+	private ScheduledFuture<?> finishTask = null;
+	private ScheduledFuture<?> timer = null;
+	private long fightBeginTime;
+	private ScheduledFuture<?> outOfTheZoneTask = null;
+	private boolean started;
+	
+	public TournamentFight(int id, TournamentFightType fightType, Instance instance, TournamentTeam teamOne, TournamentTeam teamTwo, TournamentArena tournamentArena)
+	{
+		
+		this.fightType = fightType;
+		this.id = id;
+		this.instance = instance;
+		this.teamOne = teamOne;
+		this.teamTwo = teamTwo;
+		this.tournamentArena = tournamentArena;
+		
+		teamOne.setInTournamentMatch(true);
+		teamOne.setFightId(id);
+		teamOne.setTournamentFightType(fightType);
+		teamOne.screenMessage("Match found! You will be teleported in: " + Config.TOURNAMENT_TIME_TO_TELEPORT + " seconds.");
+		teamOne.screenMessage("Match found! You will be teleported in: " + Config.TOURNAMENT_TIME_TO_TELEPORT + " seconds.");
+		teamOne.prepareToFight();
+		
+		teamTwo.setInTournamentMatch(true);
+		teamTwo.setFightId(id);
+		teamTwo.setTournamentFightType(fightType);
+		teamTwo.screenMessage("Match found! You will be teleported in: " + Config.TOURNAMENT_TIME_TO_TELEPORT + " seconds.");
+		teamTwo.screenMessage("Match found! You will be teleported in: " + Config.TOURNAMENT_TIME_TO_TELEPORT + " seconds.");
+		teamTwo.prepareToFight();
+		
+		fightBeginTime = System.currentTimeMillis();
+		TournamentManager.getInstance().getCurrentFights().put(id, this);
+		TournamentManager.getInstance().setAllTimeFights(TournamentManager.getInstance().getAllTimeFights() + 1);
+		ThreadPool.schedule(new TournamentTeleport(this, tournamentArena, teamOne, teamTwo), Config.TOURNAMENT_TIME_TO_TELEPORT * 1000);
+		finishTask = ThreadPool.schedule(new FinishFight(), (Config.TOURNAMENT_FIGHT_DURATION.get(fightType)) * 60 * 1000 + (Config.TOURNAMENT_TIME_TO_TELEPORT + Config.TOURNAMENT_FIGHT_START_TIME.get(fightType) * 1000));
+		timer = ThreadPool.scheduleAtFixedRate(new Timer(), 1000, 1010);
+		setOutOfTheZoneTask(ThreadPool.scheduleAtFixedRate(new OutOfTheZoneTask(teamOne, teamTwo), 0, 1000));
+		
+	}
+	
+	class Timer implements Runnable
+	{
+		
+		@Override
+		public void run()
+		{
+			if (isStarted())
+				broadCastTimer();
+		}
+		
+	}
+	
+	public void broadCastTimer()
+	{
+		int secondsLeft = (int) (((fightBeginTime + (1000 * 60 * Config.TOURNAMENT_FIGHT_DURATION.get(fightType) + (Config.TOURNAMENT_TIME_TO_TELEPORT + Config.TOURNAMENT_FIGHT_START_TIME.get(fightType) * 1000))) - System.currentTimeMillis()) / 1000);
+		int minutes = secondsLeft / 60;
+		int seconds = secondsLeft % 60;
+		ExShowScreenMessage packet = new ExShowScreenMessage(String.format("%02d:%02d", minutes, seconds), 1010, SMPOS.BOTTOM_RIGHT, false);
+		for (Player player : teamOne.getMembers())
+			player.sendPacket(packet);
+		for (Player player : teamTwo.getMembers())
+			player.sendPacket(packet);
+	}
+	
+	private class FinishFight implements Runnable
+	{
+		
+		@Override
+		public void run()
+		{
+			
+			finish();
+		}
+		
+	}
+	
+	class TeleportBack implements Runnable
+	{
+		TournamentTeam team;
+		
+		public TeleportBack(TournamentTeam team)
+		{
+			this.team = team;
+		}
+		
+		@Override
+		public void run()
+		{
+			team.doRevive();
+			team.teleportBack();
+			team.backInstance();
+		}
+		
+	}
+	
+	public void finish()
+	{
+		try
+		{
+			if (getWinner() != null)
+			{
+				// reward victorious team
+				getWinner().reward(true);
+				// store +1 victory
+				getWinner().addTeamVictory(fightType);
+				
+				if (getLooser() != null)
+				{
+					// reward looser team
+					getLooser().reward(false);
+					getLooser().addTeamDefeat(fightType);
+					
+				}
+				
+			}
+			else
+			{
+				teamOne.screenMessage("Fight ended in a tie!");
+				teamTwo.screenMessage("Fight ended in a tie!");
+				teamOne.addTeamTie(fightType);
+				teamTwo.addTeamTie(fightType);
+			}
+			
+			// both teams code below
+			
+			// Team One
+			teamOne.addTotalDamageToPlayers(fightType);
+			teamOne.resetTeamMatchDamage(); // reset damage
+			teamOne.setInTournamentMatch(false);
+			teamOne.setFightId(0);
+			ThreadPool.schedule(new TeleportBack(teamOne), 5000);
+			teamOne.removeTournamentTeam();
+			teamOne.setTournamentFightType(TournamentFightType.NONE);
+			// store fight
+			store(teamOne);
+			
+			// Team Two
+			teamTwo.addTotalDamageToPlayers(fightType);
+			teamTwo.resetTeamMatchDamage();// reset damage
+			teamTwo.setInTournamentMatch(false);
+			teamTwo.setFightId(0);
+			ThreadPool.schedule(new TeleportBack(teamTwo), 5000);
+			teamTwo.removeTournamentTeam();
+			teamTwo.setTournamentFightType(TournamentFightType.NONE);
+			// store fight
+			store(teamTwo);
+			
+			TournamentManager.getInstance().getCurrentFights().remove(id);
+			
+			// cancel tasks
+			if (finishTask != null)
+			{
+				finishTask.cancel(true);
+				finishTask = null;
+			}
+			
+			if (timer != null)
+			{
+				timer.cancel(true);
+				timer = null;
+			}
+			
+			if (outOfTheZoneTask != null)
+			{
+				outOfTheZoneTask.cancel(true);
+				outOfTheZoneTask = null;
+			}
+			
+		}
+		catch (Exception e)
+		{
+			TournamentManager.getInstance().debugInfo("[Tournament Fight]: Could not finish a fight: ");
+			e.printStackTrace();
+		}
+		
+	}
+	
+	public void finish(TournamentTeam winner)
+	{
+		try
+		{
+			TournamentTeam looser = null;
+			if (winner != null)
+			{
+				if (winner == teamOne)
+				{
+					looser = teamTwo;
+					
+				}
+				else
+				{
+					looser = teamOne;
+				}
+				// reward victorious team
+				winner.reward(true);
+				// store +1 victory
+				winner.addTeamVictory(fightType);
+				
+			}
+			if (looser != null)
+			{
+				looser.reward(false);
+				// reward looser team
+				looser.reward(false);
+				looser.addTeamDefeat(fightType);
+			}
+			
+			winner.sendMessage("Your team has won the battle because, players of enemy team were out of tournament zone.");
+			looser.sendMessage("Your team has lost the battle because, players of your team were out of tournament zone.");
+			
+			// both teams code below
+			
+			// Team One
+			teamOne.addTotalDamageToPlayers(fightType);
+			teamOne.resetTeamMatchDamage(); // reset damage
+			teamOne.setInTournamentMatch(false);
+			teamOne.setFightId(0);
+			ThreadPool.schedule(new TeleportBack(teamOne), 5000);
+			teamOne.removeTournamentTeam();
+			teamOne.setTournamentFightType(TournamentFightType.NONE);
+			// store fight
+			store(teamOne);
+			
+			// Team Two
+			teamTwo.addTotalDamageToPlayers(fightType);
+			teamTwo.resetTeamMatchDamage();// reset damage
+			teamTwo.setInTournamentMatch(false);
+			teamTwo.setFightId(0);
+			ThreadPool.schedule(new TeleportBack(teamTwo), 5000);
+			teamTwo.removeTournamentTeam();
+			teamTwo.setTournamentFightType(TournamentFightType.NONE);
+			// store fight
+			store(teamTwo);
+			
+			TournamentManager.getInstance().getCurrentFights().remove(id);
+			
+			// cancel tasks
+			if (finishTask != null)
+			{
+				finishTask.cancel(true);
+				finishTask = null;
+			}
+			
+			if (timer != null)
+			{
+				timer.cancel(true);
+				timer = null;
+			}
+			
+			if (outOfTheZoneTask != null)
+			{
+				outOfTheZoneTask.cancel(true);
+				outOfTheZoneTask = null;
+			}
+			
+		}
+		catch (Exception e)
+		{
+			TournamentManager.getInstance().debugInfo("[Tournament Fight]: Could not finish a fight: ");
+			e.printStackTrace();
+		}
+		
+	}
+	
+	public TournamentTeam getLooser()
+	{
+		if (getWinner() != null)
+		{
+			if (getWinner() == teamOne)
+			{
+				return teamTwo;
+			}
+			else if (getWinner() == teamTwo)
+			{
+				return teamOne;
+			}
+		}
+		return null;
+	}
+	
+	public TournamentTeam getWinner()
+	{
+		int teamOneLive = teamOne.getAliveMembers();
+		int teamTwoLive = teamTwo.getAliveMembers();
+		if (teamOneLive > teamTwoLive)
+		{
+			return teamOne;
+		}
+		else if (teamTwoLive > teamOneLive)
+		{
+			return teamTwo;
+		}
+		else if (teamOne.getTotalDamage() > teamTwo.getTotalDamage())
+		{
+			return teamOne;
+		}
+		else if (teamTwo.getTotalDamage() > teamOne.getTotalDamage())
+		{
+			return teamTwo;
+		}
+		return null;
+		
+	}
+	
+	public TournamentFightType getFightType()
+	{
+		return fightType;
+	}
+	
+	public void setFightType(TournamentFightType fightType)
+	{
+		this.fightType = fightType;
+	}
+	
+	public Instance getInstance()
+	{
+		return instance;
+	}
+	
+	public void setInstance(Instance instance)
+	{
+		this.instance = instance;
+	}
+	
+	public TournamentArena getTournamentArena()
+	{
+		return tournamentArena;
+	}
+	
+	public void setTournamentArena(TournamentArena tournamentArena)
+	{
+		this.tournamentArena = tournamentArena;
+	}
+	
+	public TournamentTeam getTeamTwo()
+	{
+		return teamTwo;
+	}
+	
+	public void setTeamTwo(TournamentTeam teamTwo)
+	{
+		this.teamTwo = teamTwo;
+	}
+	
+	public TournamentTeam getTeamOne()
+	{
+		return teamOne;
+	}
+	
+	public void setTeamOne(TournamentTeam teamOne)
+	{
+		this.teamOne = teamOne;
+	}
+	
+	public int getId()
+	{
+		return id;
+	}
+	
+	public void setId(int id)
+	{
+		this.id = id;
+	}
+	
+	public ScheduledFuture<?> getFinishTask()
+	{
+		return finishTask;
+	}
+	
+	public void setFinishTask(ScheduledFuture<?> finishTask)
+	{
+		this.finishTask = finishTask;
+	}
+	
+	/**
+	 * @return the outOfTheZoneTask
+	 */
+	public ScheduledFuture<?> getOutOfTheZoneTask()
+	{
+		return outOfTheZoneTask;
+	}
+	
+	/**
+	 * @param outOfTheZoneTask the outOfTheZoneTask to set
+	 */
+	public void setOutOfTheZoneTask(ScheduledFuture<?> outOfTheZoneTask)
+	{
+		this.outOfTheZoneTask = outOfTheZoneTask;
+	}
+	
+	/**
+	 * @return the started
+	 */
+	public boolean isStarted()
+	{
+		return started;
+	}
+	
+	/**
+	 * @param started the started to set
+	 */
+	public void setStarted(boolean started)
+	{
+		this.started = started;
+	}
+	
+	public void store(TournamentTeam team)
+	{
+		for (Player member : team.getMembers())
+			TournamentManager.getInstance().updateData(member, fightType);
+	}
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/TournamentSearchFights.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/TournamentSearchFights.java
new file mode 100644
index 0000000..d2d3a96
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/TournamentSearchFights.java
@@ -0,0 +1,91 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.tasks;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.sf.l2j.commons.random.Rnd;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.idfactory.IdFactory;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.Data.TournamentArenaParser;
+import net.sf.l2j.gameserver.model.entity.Tournament.enums.TournamentFightType;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentArena;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+import net.sf.l2j.gameserver.model.entity.instance.Instance;
+import net.sf.l2j.gameserver.model.entity.instance.InstanceManager;
+
+public class TournamentSearchFights implements Runnable
+{
+	
+	private List<TournamentTeam> teams = new ArrayList<>();
+	
+	private TournamentFightType fightType;
+	
+	public TournamentSearchFights(TournamentFightType fightType)
+	{
+		this.fightType = fightType;
+	}
+	
+	@Override
+	public void run()
+	{
+		teams = TournamentManager.getInstance().getRegisteredTeamsByType(fightType);
+		if (teams.size() >= 2)
+		{
+			try
+			{
+				if (Config.TOURNAMENT_DEBUG)
+				{
+					TournamentManager.getInstance().debugInfo("Tournament is Searching for " + fightType.name() + " fights.");
+				}
+				boolean found = false;
+				// Search teams for a new fight
+				List<TournamentTeam> searchList = teams;
+				int teamOneIndex = Rnd.get(searchList.size());
+				TournamentTeam teamOne = searchList.get(teamOneIndex);
+				searchList.remove(teamOneIndex);
+				int teamTwoIndex = Rnd.get(searchList.size());
+				TournamentTeam teamTwo = searchList.get(teamTwoIndex);
+				searchList.clear();
+				if (teamOne != teamTwo)
+				{
+					found = true;
+				}
+				
+				// Create a new tournament fight
+				if (found)
+				{
+					// remove teams from registered list
+					TournamentManager.getInstance().getRegisteredTournamentTeams().remove(teamOne);
+					TournamentManager.getInstance().getRegisteredTournamentTeams().remove(teamTwo);
+					
+					// Select an arena properly
+					TournamentArena arena = TournamentArenaParser.getInstance().getRandomArenaForType(fightType);
+					// Create a instance to run the match
+					Instance instance = InstanceManager.getInstance().createInstance();
+					
+					int fightId = IdFactory.getInstance().getNextId();
+					if (arena != null)
+					{
+						TournamentFight fight = new TournamentFight(fightId, fightType, instance, teamOne, teamTwo, arena);
+						
+						if (Config.TOURNAMENT_DEBUG)
+						{
+							TournamentManager.getInstance().debugInfo("A new fight (ID: " + fight.getId() + ") [" + fightType.name() + "] started: " + teamOne.getName() + " vs " + teamTwo.getName());
+						}
+						
+					}
+					
+				}
+			}
+			catch (Exception e)
+			{
+				TournamentManager.getInstance().debugInfo("[Tournament Search Fights]: Could not start a fight: ");
+				e.printStackTrace();
+				
+			}
+			
+		}
+	}
+}
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/TournamentTeleport.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/TournamentTeleport.java
new file mode 100644
index 0000000..b8b5baf
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/Tournament/tasks/TournamentTeleport.java
@@ -0,0 +1,175 @@
+package net.sf.l2j.gameserver.model.entity.Tournament.tasks;
+
+import java.util.List;
+
+import net.sf.l2j.commons.pool.ThreadPool;
+
+import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentArena;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+import net.sf.l2j.gameserver.model.location.Location;
+
+public class TournamentTeleport implements Runnable
+{
+	
+	private TournamentArena arena;
+	private TournamentFight fight;
+	private TournamentTeam teamOne;
+	private TournamentTeam teamTwo;
+	
+	public TournamentTeleport(TournamentFight fight, TournamentArena arena, TournamentTeam teamOne, TournamentTeam teamTwo)
+	{
+		this.fight = fight;
+		this.arena = arena;
+		this.teamOne = teamOne;
+		this.teamTwo = teamTwo;
+	}
+	
+	@Override
+	public void run()
+	{
+		teleportTeamOne();
+		teleportTeamTwo();
+		teamOne.paralyze();
+		teamTwo.paralyze();
+		teamOne.screenMessage("Fight will start in " + Config.TOURNAMENT_FIGHT_START_TIME.get(fight.getFightType()) + " seconds");
+		teamTwo.screenMessage("Fight will start in " + Config.TOURNAMENT_FIGHT_START_TIME.get(fight.getFightType()) + " seconds");
+		
+		ThreadPool.schedule(new Unparalyze(), Config.TOURNAMENT_FIGHT_START_TIME.get(fight.getFightType()) * 1000);
+		
+	}
+	
+	class Unparalyze implements Runnable
+	{
+		
+		@Override
+		public void run()
+		{
+			teamOne.unparalyze();
+			teamTwo.unparalyze();
+			fight.setStarted(true);
+			teamOne.screenMessage("Battle Started!");
+			teamTwo.screenMessage("Battle Started!");
+			
+		}
+		
+	}
+	
+	public void teleportTeamOne()
+	{
+		int locIndex = 0;
+		for (Player player : teamOne.getMembers())
+		{
+			if (!player.isOnline())
+				continue;
+			
+			List<Location> locs = arena.getTeamOneLocation();
+			Location loc = locs.get(locIndex);
+			if (loc != null)
+			{
+				player.setLastX(player.getPosition().getX());
+				player.setLastY(player.getPosition().getY());
+				player.setLastZ(player.getPosition().getZ());
+				player.setInstance(fight.getInstance(), true);
+				player.teleToLocation(loc);
+				locIndex++;
+			}
+			else
+			{
+				fight.getTeamOne().sendMessage("Something goes wrong with locations of team one, please, contact and Admin.");
+				fight.getTeamTwo().sendMessage("Something goes wrong with locations of team one, please, contact and Admin.");
+				fight.finish();
+			}
+			
+		}
+	}
+	
+	public void teleportTeamTwo()
+	{
+		int locIndex = 0;
+		for (Player player : teamTwo.getMembers())
+		{
+			if (!player.isOnline())
+				continue;
+			
+			List<Location> locs = arena.getTeamTwoLocation();
+			Location loc = locs.get(locIndex);
+			if (loc != null)
+			{
+				player.setLastX(player.getPosition().getX());
+				player.setLastY(player.getPosition().getY());
+				player.setLastZ(player.getPosition().getZ());
+				player.setInstance(fight.getInstance(), true);
+				player.teleToLocation(loc);
+				locIndex++;
+			}
+			else
+			{
+				fight.getTeamOne().sendMessage("Something goes wrong with locations of team two, please, contact and Admin.");
+				fight.getTeamTwo().sendMessage("Something goes wrong with locations of team two, please, contact and Admin.");
+				fight.finish();
+			}
+			
+		}
+	}
+	
+	/**
+	 * @return the arena
+	 */
+	public TournamentArena getArena()
+	{
+		return arena;
+	}
+	
+	/**
+	 * @param arena the arena to set
+	 */
+	public void setArena(TournamentArena arena)
+	{
+		this.arena = arena;
+	}
+	
+	/**
+	 * @return the teamOne
+	 */
+	public TournamentTeam getTeamOne()
+	{
+		return teamOne;
+	}
+	
+	/**
+	 * @param teamOne the teamOne to set
+	 */
+	public void setTeamOne(TournamentTeam teamOne)
+	{
+		this.teamOne = teamOne;
+	}
+	
+	/**
+	 * @return the teamTwo
+	 */
+	public TournamentTeam getTeamTwo()
+	{
+		return teamTwo;
+	}
+	
+	/**
+	 * @param teamTwo the teamTwo to set
+	 */
+	public void setTeamTwo(TournamentTeam teamTwo)
+	{
+		this.teamTwo = teamTwo;
+	}
+	
+	public TournamentFight getFight()
+	{
+		return fight;
+	}
+	
+	public void setFight(TournamentFight fight)
+	{
+		this.fight = fight;
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/instance/Instance.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/instance/Instance.java
new file mode 100644
index 0000000..5e5912d
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/instance/Instance.java
@@ -0,0 +1,48 @@
+package net.sf.l2j.gameserver.model.entity.instance;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.sf.l2j.gameserver.model.actor.instance.Door;
+
+/**
+ * @author Anarchy
+ */
+public class Instance
+{
+	private int id;
+	private List<Door> doors;
+	
+	public Instance(int id)
+	{
+		this.id = id;
+		doors = new ArrayList<>();
+	}
+	
+	public void openDoors()
+	{
+		for (Door door : doors)
+			door.openMe();
+	}
+	
+	public void closeDoors()
+	{
+		for (Door door : doors)
+			door.closeMe();
+	}
+	
+	public void addDoor(Door door)
+	{
+		doors.add(door);
+	}
+	
+	public List<Door> getDoors()
+	{
+		return doors;
+	}
+	
+	public int getId()
+	{
+		return id;
+	}
+}
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/instance/InstanceIdFactory.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/instance/InstanceIdFactory.java
new file mode 100644
index 0000000..44420a3
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/instance/InstanceIdFactory.java
@@ -0,0 +1,17 @@
+package net.sf.l2j.gameserver.model.entity.instance;
+
+import java.util.concurrent.atomic.AtomicInteger;
+
+/**
+ * @author Anarchy
+ *
+ */
+public final class InstanceIdFactory
+{
+	private static AtomicInteger nextAvailable = new AtomicInteger(1);
+	
+	public synchronized static int getNextAvailable()
+	{
+		return nextAvailable.getAndIncrement();
+	}
+}
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/instance/InstanceManager.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/instance/InstanceManager.java
new file mode 100644
index 0000000..003f927
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/entity/instance/InstanceManager.java
@@ -0,0 +1,62 @@
+package net.sf.l2j.gameserver.model.entity.instance;
+
+import java.util.Map;
+import java.util.concurrent.ConcurrentHashMap;
+
+import net.sf.l2j.gameserver.model.actor.instance.Door;
+
+/**
+ * @author Anarchy
+ *
+ */
+public class InstanceManager
+{
+	private Map<Integer, Instance> instances;
+	
+	protected InstanceManager()
+	{
+		instances = new ConcurrentHashMap<>();
+		instances.put(0, new Instance(0));
+	}
+	
+	public void addDoor(int id, Door door)
+	{
+		if (!instances.containsKey(id) || id == 0)
+			return;
+		
+		instances.get(id).addDoor(door);
+	}
+	
+	public void deleteInstance(int id)
+	{
+		if (id == 0)
+		{
+			System.out.println("Attempt to delete instance with id 0.");
+			return;
+		}
+		
+		// delete doors
+	}
+	
+	public synchronized Instance createInstance()
+	{
+		Instance instance = new Instance(InstanceIdFactory.getNextAvailable());
+		instances.put(instance.getId(), instance);
+		return instance;
+	}
+	
+	public Instance getInstance(int id)
+	{
+		return instances.get(id);
+	}
+	
+	public static InstanceManager getInstance()
+	{
+		return SingletonHolder.instance;
+	}
+	
+	private static final class SingletonHolder
+	{
+		protected static final InstanceManager instance = new InstanceManager();
+	}
+}
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/zone/SpawnZone.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/zone/SpawnZone.java
new file mode 100644
index 0000000..8af0d1e
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/zone/SpawnZone.java
@@ -0,0 +1,58 @@
+package net.sf.l2j.gameserver.model.zone;
+
+import java.util.ArrayList;
+import java.util.List;
+
+import net.sf.l2j.commons.random.Rnd;
+
+import net.sf.l2j.gameserver.model.location.Location;
+import net.sf.l2j.gameserver.model.zone.type.subtype.ZoneType;
+
+/**
+ * Abstract zone with spawn locations.<br>
+ * It inherits regular L2ZoneType behavior, with the possible addition of 2 Lists holding Locations.
+ */
+public abstract class SpawnZone extends ZoneType
+{
+	private List<Location> _spawnLocs = null;
+	private List<Location> _chaoticSpawnLocs = null;
+	
+	public SpawnZone(int id)
+	{
+		super(id);
+	}
+	
+	public final void addSpawn(int x, int y, int z)
+	{
+		if (_spawnLocs == null)
+			_spawnLocs = new ArrayList<>();
+		
+		_spawnLocs.add(new Location(x, y, z));
+	}
+	
+	public final void addChaoticSpawn(int x, int y, int z)
+	{
+		if (_chaoticSpawnLocs == null)
+			_chaoticSpawnLocs = new ArrayList<>();
+		
+		_chaoticSpawnLocs.add(new Location(x, y, z));
+	}
+	
+	public final List<Location> getSpawns()
+	{
+		return _spawnLocs;
+	}
+	
+	public final Location getSpawnLoc()
+	{
+		return Rnd.get(_spawnLocs);
+	}
+	
+	public final Location getChaoticSpawnLoc()
+	{
+		if (_chaoticSpawnLocs != null)
+			return Rnd.get(_chaoticSpawnLocs);
+		
+		return getSpawnLoc();
+	}
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/model/zone/type/TournamentZone.java b/aCis_gameserver/java/net/sf/l2j/gameserver/model/zone/type/TournamentZone.java
new file mode 100644
index 0000000..bbc9172
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/model/zone/type/TournamentZone.java
@@ -0,0 +1,51 @@
+package net.sf.l2j.gameserver.model.zone.type;
+
+import net.sf.l2j.gameserver.enums.ZoneId;
+import net.sf.l2j.gameserver.model.actor.Creature;
+import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.zone.SpawnZone;
+import net.sf.l2j.gameserver.network.SystemMessageId;
+
+/**
+ * @author Rouxy
+ */
+public class TournamentZone extends SpawnZone
+{
+	
+	@Override
+	public void setParameter(String name, String value)
+	{
+		
+		super.setParameter(name, value);
+	}
+	
+	public TournamentZone(int id)
+	{
+		super(id);
+		
+	}
+	
+	@Override
+	protected void onEnter(Creature character)
+	{
+		character.setInsideZone(ZoneId.TOURNAMENT, true);
+		if (character instanceof Player)
+			((Player) character).sendPacket(SystemMessageId.ENTERED_COMBAT_ZONE);
+		
+		character.setInsideZone(ZoneId.PVP, true);
+		character.setInsideZone(ZoneId.NO_SUMMON_FRIEND, true);
+	}
+	
+	@Override
+	protected void onExit(Creature character)
+	{
+		character.setInsideZone(ZoneId.TOURNAMENT, false);
+		character.setInsideZone(ZoneId.PVP, false);
+		character.setInsideZone(ZoneId.NO_SUMMON_FRIEND, false);
+		
+		if (character instanceof Player)
+			((Player) character).sendPacket(SystemMessageId.LEFT_COMBAT_ZONE);
+		
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/network/GameClient.java b/aCis_gameserver/java/net/sf/l2j/gameserver/network/GameClient.java
index b5feb6f..2e0df1a 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/network/GameClient.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/network/GameClient.java
@@ -9,6 +9,7 @@
 import java.util.concurrent.RejectedExecutionException;
 import java.util.concurrent.ScheduledFuture;
 import java.util.concurrent.locks.ReentrantLock;
+import java.util.logging.Level;
 
 import net.sf.l2j.commons.logging.CLogger;
 import net.sf.l2j.commons.mmocore.MMOClient;
@@ -21,10 +22,14 @@
 import net.sf.l2j.gameserver.LoginServerThread;
 import net.sf.l2j.gameserver.data.sql.ClanTable;
 import net.sf.l2j.gameserver.data.sql.PlayerInfoTable;
+import net.sf.l2j.gameserver.data.xml.MapRegionData;
+import net.sf.l2j.gameserver.data.xml.MapRegionData.TeleportType;
 import net.sf.l2j.gameserver.enums.FloodProtector;
 import net.sf.l2j.gameserver.model.CharSelectSlot;
 import net.sf.l2j.gameserver.model.World;
 import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.instance.InstanceManager;
 import net.sf.l2j.gameserver.model.pledge.Clan;
 import net.sf.l2j.gameserver.network.serverpackets.ActionFailed;
 import net.sf.l2j.gameserver.network.serverpackets.L2GameServerPacket;
@@ -203,19 +208,45 @@
 	{
 		try
 		{
-			ThreadPool.execute(() ->
+			ThreadPool.execute(new DisconnectTask());
+		}
+		catch (RejectedExecutionException e)
+		{
+		}
+	}
+	
+	protected class DisconnectTask implements Runnable
+	{
+		@Override
+		public void run()
+		{
+			boolean fast = true;
+			try
 			{
-				boolean fast = true;
 				if (getPlayer() != null && !isDetached())
 				{
 					setDetached(true);
 					fast = !getPlayer().isInCombat() && !getPlayer().isLocked();
 				}
+				
+				// Rouxy: Instance Mod
+				Player player = getPlayer();
+				if (player != null)
+				{
+					if (player.getInstance() != null && player.getInstance().getId() != 0)
+					{
+						player.setInstance(InstanceManager.getInstance().getInstance(0), true);
+						player.teleToLocation(MapRegionData.getInstance().getLocationToTeleport(player, TeleportType.TOWN));
+					}
+				}
+				// Rouxy: Tournament
+				TournamentManager.getInstance().onDisconnect(player);
 				cleanMe(fast);
-			});
-		}
-		catch (RejectedExecutionException e)
-		{
+			}
+			catch (Exception e1)
+			{
+				LOGGER.info(Level.WARNING, "error while disconnecting client", e1);
+			}
 		}
 	}
 	
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/DlgAnswer.java b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/DlgAnswer.java
index ff5ad4a..f367cea 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/DlgAnswer.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/DlgAnswer.java
@@ -1,8 +1,14 @@
 package net.sf.l2j.gameserver.network.clientpackets;
 
 import net.sf.l2j.Config;
+import net.sf.l2j.gameserver.enums.LootRule;
+import net.sf.l2j.gameserver.model.World;
 import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
+import net.sf.l2j.gameserver.model.entity.Tournament.model.TournamentTeam;
+import net.sf.l2j.gameserver.model.group.Party;
 import net.sf.l2j.gameserver.network.SystemMessageId;
+import net.sf.l2j.gameserver.network.serverpackets.ExShowScreenMessage;
 
 public final class DlgAnswer extends L2GameClientPacket
 {
@@ -35,5 +41,88 @@
 			player.activateGate(_answer, 1);
 		else if (_messageId == SystemMessageId.WOULD_YOU_LIKE_TO_CLOSE_THE_GATE.getId())
 			player.activateGate(_answer, 0);
+		
+		else if (_messageId == SystemMessageId.S1.getId())
+		{
+			if (TournamentManager.getInstance().isTournamentTeleporting())
+			{
+				if (_answer == 1)
+				{
+					player.teleportTo(Config.TOURNAMENT_NPC_LOCATION.getX(), Config.TOURNAMENT_NPC_LOCATION.getY(), Config.TOURNAMENT_NPC_LOCATION.getZ(), 500);
+				}
+			}
+			else if (player.isTournamentTeamBeingInvited())
+			{
+				Player leader = World.getInstance().getPlayer(player.getTournamentTeamRequesterId());
+				if (leader != null)
+				{
+					TournamentTeam team = leader.getTournamentTeam();
+					if (_answer == 1)
+					{
+						if (team == null)
+						{
+							team = new TournamentTeam(leader, player);
+							player.sendPacket(new ExShowScreenMessage("Your Team have been created!", 3000));
+						}
+						else
+						{
+							team.addMember(player);
+							leader.sendPacket(new ExShowScreenMessage(player.getName() + " entered your team.", 3000));
+							player.sendPacket(new ExShowScreenMessage("You entered " + team.getName() + ".", 3000));
+						}
+						Party party = leader.getParty();
+						if (party != null)
+						{
+							party.addPartyMember(player);
+						}
+						else
+						{
+							party = new Party(leader, player, LootRule.ITEM_LOOTER);
+							team.setParty(party);
+						}
+						// String pageToOpen = null;
+						// TournamentFightType type = TournamentFightType.NONE;
+						// switch (team.getMembers().size())
+						// {
+						// case 1:
+						// pageToOpen = "fights/F1X1";
+						// type = TournamentFightType.F1X1;
+						// break;
+						// case 2:
+						// pageToOpen = "fights/F2X2";
+						// type = TournamentFightType.F2X2;
+						// break;
+						// case 3:
+						// pageToOpen = "fights/F3X3";
+						// type = TournamentFightType.F3X3;
+						// break;
+						// case 4:
+						// pageToOpen = "fights/F4X4";
+						// type = TournamentFightType.F4X4;
+						// break;
+						// case 5:
+						// pageToOpen = "fights/F5X5";
+						// type = TournamentFightType.F5X5;
+						// break;
+						// case 9:
+						// pageToOpen = "fights/F9X9";
+						// type = TournamentFightType.F9X9;
+						// break;
+						//
+						// }
+						// TournamentManager.getInstance().showHtml(leader, pageToOpen, type);
+						// TournamentManager.getInstance().showHtml(player, pageToOpen, type);
+						
+					}
+					else
+					{
+						leader.sendMessage(player.getName() + " denied your Tournament Team request.");
+						return;
+					}
+				}
+				player.setTournamentTeamRequesterId(0);
+				player.setTournamentTeamBeingInvited(false);
+			}
+		}
 	}
 }
\ No newline at end of file
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/Logout.java b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/Logout.java
index 7a65c66..6648a54 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/Logout.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/Logout.java
@@ -3,6 +3,7 @@
 import net.sf.l2j.gameserver.data.manager.FestivalOfDarknessManager;
 import net.sf.l2j.gameserver.enums.ZoneId;
 import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
 import net.sf.l2j.gameserver.network.SystemMessageId;
 import net.sf.l2j.gameserver.network.serverpackets.ActionFailed;
 import net.sf.l2j.gameserver.taskmanager.AttackStanceTaskManager;
@@ -48,6 +49,7 @@
 			return;
 		}
 		
+		TournamentManager.getInstance().onDisconnect(player);
 		player.removeFromBossZone();
 		player.logout(true);
 	}
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestBypassToServer.java b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestBypassToServer.java
index d3a2c47..b635597 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestBypassToServer.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestBypassToServer.java
@@ -9,7 +9,11 @@
 import net.sf.l2j.gameserver.data.xml.AdminData;
 import net.sf.l2j.gameserver.enums.FloodProtector;
 import net.sf.l2j.gameserver.handler.AdminCommandHandler;
+import net.sf.l2j.gameserver.handler.BypassHandler;
 import net.sf.l2j.gameserver.handler.IAdminCommandHandler;
+import net.sf.l2j.gameserver.handler.IBypassHandler;
+import net.sf.l2j.gameserver.handler.IVoicedCommandHandler;
+import net.sf.l2j.gameserver.handler.VoicedCommandHandler;
 import net.sf.l2j.gameserver.model.World;
 import net.sf.l2j.gameserver.model.WorldObject;
 import net.sf.l2j.gameserver.model.actor.Npc;
@@ -72,6 +76,17 @@
 			
 			ach.useAdminCommand(_command, player);
 		}
+		else if (_command.startsWith("bp_"))
+		{
+			String command = _command.split(" ")[0];
+			IBypassHandler bh = BypassHandler.getInstance().getBypassHandler(command);
+			if (bh == null)
+			{
+				GMAUDIT_LOG.warning("No handler registered for bypass '" + command + "'");
+				return;
+			}
+			bh.handleBypass(_command, player);
+		}
 		else if (_command.startsWith("player_help "))
 		{
 			final String path = _command.substring(12);
@@ -98,6 +113,18 @@
 			html.disableValidation();
 			player.sendPacket(html);
 		}
+		else if (_command.startsWith("voiced_"))
+		{
+		String command = _command.split(" ")[0];
+		IVoicedCommandHandler ach = VoicedCommandHandler.getInstance().getVoicedCommandHandler(_command.substring(7));
+		if (ach == null)
+		{
+			player.sendMessage("The command " + command.substring(7) + " does not exist!");
+			LOGGER.warn("No handler registered for command '" + _command + "'");
+			return;
+		}
+		ach.useVoicedCommand(_command.substring(7), player, null);
+		}
 		else if (_command.startsWith("npc_"))
 		{
 			if (!player.validateBypass(_command))
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestJoinParty.java b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestJoinParty.java
index f63a702..e3502ed 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestJoinParty.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestJoinParty.java
@@ -64,6 +64,12 @@
 			return;
 		}
 		
+		if (requestor.isInTournamentMatch())
+		{
+			requestor.sendMessage("You can't invite players in Tournament.");
+			return;
+		}
+
 		if (target.isInJail() || requestor.isInJail())
 		{
 			requestor.sendMessage("The player you tried to invite is currently jailed.");
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestRestart.java b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestRestart.java
index 3520e73..ac68f62 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestRestart.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/RequestRestart.java
@@ -3,6 +3,7 @@
 import net.sf.l2j.gameserver.data.manager.FestivalOfDarknessManager;
 import net.sf.l2j.gameserver.enums.ZoneId;
 import net.sf.l2j.gameserver.model.actor.Player;
+import net.sf.l2j.gameserver.model.entity.Tournament.TournamentManager;
 import net.sf.l2j.gameserver.network.GameClient;
 import net.sf.l2j.gameserver.network.GameClient.GameClientState;
 import net.sf.l2j.gameserver.network.SystemMessageId;
@@ -51,6 +52,7 @@
 			return;
 		}
 		
+		TournamentManager.getInstance().onDisconnect(player);
 		player.removeFromBossZone();
 		
 		final GameClient client = getClient();
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/UseItem.java b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/UseItem.java
index f3eb170..8c42949 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/UseItem.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/network/clientpackets/UseItem.java
@@ -65,6 +65,15 @@
 			return;
 		}
 		
+		if (player.getActingPlayer().isInTournamentMatch())
+		{
+			if (Config.TOURNAMENT_RESTRICTED_ITEM_LIST.contains(item.getItem().getItemId()))
+			{
+				player.sendMessage("You can't use this item in Tournament.");
+				return;
+			}
+		}
+
 		if (player.isAlikeDead() || player.isStunned() || player.isSleeping() || player.isParalyzed() || player.isAfraid())
 			return;
 		
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/Die.java b/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/Die.java
index 50e57f0..70ecb70 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/Die.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/Die.java
@@ -18,6 +18,8 @@
 	private boolean _allowFixedRes;
 	private Clan _clan;
 	
+	private boolean _canTeleport;
+	
 	public Die(Creature creature)
 	{
 		_creature = creature;
@@ -26,6 +28,8 @@
 		
 		if (creature instanceof Player)
 		{
+			
+			_canTeleport = !creature.getActingPlayer().isInTournamentMatch();
 			Player player = (Player) creature;
 			_allowFixedRes = player.getAccessLevel().allowFixedRes();
 			_clan = player.getClan();
@@ -43,7 +47,8 @@
 		
 		writeC(0x06);
 		writeD(_objectId);
-		writeD(0x01); // to nearest village
+		writeD(_canTeleport ? 0x01 : 0); // to nearest village
+//		writeD(0x01); // to nearest village
 		
 		if (_clan != null)
 		{
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/NpcHtmlMessage.java b/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/NpcHtmlMessage.java
index e483774..4f61db1 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/NpcHtmlMessage.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/network/serverpackets/NpcHtmlMessage.java
@@ -14,6 +14,22 @@
 	private String _html;
 	private String _file;
 	
+	/**
+	 * @return the _file
+	 */
+	public String getFile()
+	{
+		return _file;
+	}
+	
+	/**
+	 * @param _file the _file to set
+	 */
+	public void set_file(String _file)
+	{
+		this._file = _file;
+	}
+
 	private int _itemId = 0;
 	private boolean _validate = true;
 	
diff --git a/aCis_gameserver/java/net/sf/l2j/gameserver/skills/l2skills/L2SkillSummon.java b/aCis_gameserver/java/net/sf/l2j/gameserver/skills/l2skills/L2SkillSummon.java
index 4760106..bff848a 100644
--- a/aCis_gameserver/java/net/sf/l2j/gameserver/skills/l2skills/L2SkillSummon.java
+++ b/aCis_gameserver/java/net/sf/l2j/gameserver/skills/l2skills/L2SkillSummon.java
@@ -158,6 +158,7 @@
 			spawnLoc.setHeadingTo(activeChar.getPosition());
 			spawnLoc.set(GeoEngine.getInstance().getValidLocation(activeChar, spawnLoc));
 			
+			summon.setInstance(activeChar.getInstance(), true);
 			summon.spawnMe(spawnLoc);
 			summon.getAI().setFollowStatus(true);
 			
diff --git a/aCis_gameserver/java/net/sf/l2j/util/Mysql.java b/aCis_gameserver/java/net/sf/l2j/util/Mysql.java
new file mode 100644
index 0000000..193f445
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/util/Mysql.java
@@ -0,0 +1,187 @@
+package net.sf.l2j.util;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+import java.sql.SQLException;
+import java.sql.Statement;
+import java.util.logging.Logger;
+
+import net.sf.l2j.commons.pool.ConnectionPool;
+
+public abstract class Mysql
+{
+	private static final Logger _log = Logger.getLogger(Mysql.class.getName());
+	
+	/**
+	 * Performs a simple sql queries where unnecessary control parameters <BR>
+	 * NOTE: In this method, the parameters passed are not valid for SQL-injection!
+	 * @param db
+	 * @param query
+	 * @param vars
+	 * @return
+	 */
+	public static boolean setEx(ConnectionPool db, String query, Object... vars)
+	{
+		Connection con = null;
+		Statement statement = null;
+		PreparedStatement pstatement = null;
+		boolean successed = true;
+		
+		try
+		{
+			if (db == null)
+				db = new ConnectionPool();
+			
+			con = db.getConnection();
+			if (vars.length == 0)
+			{
+				statement = con.createStatement();
+				statement.executeUpdate(query);
+				statement.close();
+			}
+			else
+			{
+				pstatement = con.prepareStatement(query);
+				setVars(pstatement, vars);
+				pstatement.executeUpdate();
+				pstatement.close();
+			}
+			con.close();
+		}
+		catch (Exception e)
+		{
+			_log.warning("Could not execute update '" + query + "': " + e);
+			e.printStackTrace();
+			successed = false;
+		}
+		finally
+		{
+			closeQuietly(con, pstatement);
+			closeQuietly(statement);
+		}
+		return successed;
+	}
+	
+	public static void setVars(PreparedStatement statement, Object... vars) throws SQLException
+	{
+		Number n;
+		long long_val;
+		double double_val;
+		for (int i = 0; i < vars.length; i++)
+			if (vars[i] instanceof Number)
+			{
+				n = (Number) vars[i];
+				long_val = n.longValue();
+				double_val = n.doubleValue();
+				if (long_val == double_val)
+					statement.setLong(i + 1, long_val);
+				else
+					statement.setDouble(i + 1, double_val);
+			}
+			else if (vars[i] instanceof String)
+				statement.setString(i + 1, (String) vars[i]);
+	}
+	
+	public static boolean set(String query, Object... vars)
+	{
+		return setEx(null, query, vars);
+	}
+	
+	public static boolean set(String query)
+	{
+		return setEx(null, query);
+	}
+	
+	public static void closeQuietly(Connection conn)
+	{
+		try
+		{
+			close(conn);
+		}
+		catch (SQLException e)
+		{ // NOPMD
+			// quiet
+		}
+	}
+	
+	public static void closeQuietly(Connection conn, Statement stmt, ResultSet rs)
+	{
+		
+		try
+		{
+			closeQuietly(rs);
+		}
+		finally
+		{
+			try
+			{
+				closeQuietly(stmt);
+			}
+			finally
+			{
+				closeQuietly(conn);
+			}
+		}
+	}
+	
+	public static void closeQuietly(Connection conn, Statement stmt)
+	{
+		try
+		{
+			closeQuietly(stmt);
+		}
+		finally
+		{
+			closeQuietly(conn);
+		}
+	}
+	
+	public static void closeQuietly(ResultSet rs)
+	{
+		try
+		{
+			close(rs);
+		}
+		catch (SQLException e)
+		{ // NOPMD
+			// quiet
+		}
+	}
+	
+	public static void closeQuietly(Statement stmt)
+	{
+		try
+		{
+			close(stmt);
+		}
+		catch (SQLException e)
+		{ // NOPMD
+			// quiet
+		}
+	}
+	
+	public static void close(Connection conn) throws SQLException
+	{
+		if (conn != null)
+		{
+			conn.close();
+		}
+	}
+	
+	public static void close(ResultSet rs) throws SQLException
+	{
+		if (rs != null)
+		{
+			rs.close();
+		}
+	}
+	
+	public static void close(Statement stmt) throws SQLException
+	{
+		if (stmt != null)
+		{
+			stmt.close();
+		}
+	}
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/util/PlayerVar.java b/aCis_gameserver/java/net/sf/l2j/util/PlayerVar.java
new file mode 100644
index 0000000..45e6982
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/util/PlayerVar.java
@@ -0,0 +1,122 @@
+package net.sf.l2j.util;
+
+import java.util.concurrent.ScheduledFuture;
+
+import net.sf.l2j.commons.pool.ThreadPool;
+
+import net.sf.l2j.gameserver.model.actor.Player;
+
+public class PlayerVar
+{
+	private Player owner;
+	private String name;
+	private String value;
+	private long expire_time;
+	
+	@SuppressWarnings("rawtypes")
+	private ScheduledFuture task;
+	
+	public PlayerVar(Player owner, String name, String value, long expire_time)
+	{
+		this.owner = owner;
+		this.name = name;
+		this.value = value;
+		this.expire_time = expire_time;
+		
+		if (expire_time > 0) // if expires schedule expiration
+		{
+			task = ThreadPool.schedule(new PlayerVarExpireTask(this), expire_time - System.currentTimeMillis());
+		}
+	}
+	
+	public int getIntValue()
+	{
+		if (isNumeric(getValue()))
+		{
+			return Integer.parseInt(getValue());
+		}
+		return -1;
+	}
+	
+	public String getName()
+	{
+		return name;
+	}
+	
+	public Player getOwner()
+	{
+		return owner;
+	}
+	
+	public boolean hasExpired()
+	{
+		return task == null || task.isDone();
+	}
+	
+	public long getTimeToExpire()
+	{
+		return expire_time - System.currentTimeMillis();
+	}
+	
+	public String getValue()
+	{
+		return value;
+	}
+	
+	public boolean getValueBoolean()
+	{
+		if (isNumeric(value))
+			return Integer.parseInt(value) > 0;
+		
+		return value.equalsIgnoreCase("true");
+	}
+	
+	public void setValue(String val)
+	{
+		value = val;
+	}
+	
+	public void stopExpireTask()
+	{
+		if (task != null && !task.isDone())
+		{
+			task.cancel(true);
+		}
+	}
+	
+	private static class PlayerVarExpireTask implements Runnable
+	{
+		private PlayerVar _pv;
+		
+		public PlayerVarExpireTask(PlayerVar pv)
+		{
+			_pv = pv;
+		}
+		
+		@Override
+		public void run()
+		{
+			Player pc = _pv.getOwner();
+			if (pc == null)
+			{
+				return;
+			}
+			
+			PlayerVariables.unsetVar(pc, _pv.getName());
+		}
+	}
+	
+	public boolean isNumeric(String str)
+	{
+		try
+		{
+			@SuppressWarnings("unused")
+			double d = Double.parseDouble(str);
+		}
+		catch (NumberFormatException nfe)
+		{
+			return false;
+		}
+		return true;
+	}
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/util/PlayerVariables.java b/aCis_gameserver/java/net/sf/l2j/util/PlayerVariables.java
new file mode 100644
index 0000000..9c7ddc9
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/util/PlayerVariables.java
@@ -0,0 +1,351 @@
+package net.sf.l2j.util;
+
+import java.sql.Connection;
+import java.sql.PreparedStatement;
+import java.sql.ResultSet;
+
+import net.sf.l2j.commons.pool.ConnectionPool;
+
+import net.sf.l2j.gameserver.model.actor.Player;
+
+/**
+ * @author DevKatara
+ */
+public class PlayerVariables
+{
+	// When var exist
+	public static void changeValue(Player player, String name, String value)
+	{
+		if (!player.getVariables().containsKey(name))
+		{
+			player.sendMessage("Variable is not exist...");
+			return;
+		}
+		
+		getVarObject(player, name).setValue(value);
+		Mysql.set("UPDATE character_memo_alt SET value=? WHERE obj_id=? AND name=?", value, player.getObjectId(), name);
+	}
+	
+	public static void setVar(Player player, String name, String value, long expirationTime)
+	{
+		if (player.getVariables().containsKey(name))
+			getVarObject(player, name).stopExpireTask();
+		
+		player.getVariables().put(name, new PlayerVar(player, name, value, expirationTime));
+		Mysql.set("REPLACE INTO character_memo_alt (obj_id, name, value, expire_time) VALUES (?,?,?,?)", player.getObjectId(), name, value, expirationTime);
+	}
+	
+	public static void setVar(int objId, String name, String value, long expirationTime)
+	{
+		Mysql.set("REPLACE INTO character_memo_alt (obj_id, name, value, expire_time) VALUES (?,?,?,?)", objId, name, value, expirationTime);
+	}
+	
+	public static void setVar(Player player, String name, int value, long expirationTime)
+	{
+		setVar(player, name, String.valueOf(value), expirationTime);
+	}
+	
+	public void setVar(Player player, String name, long value, long expirationTime)
+	{
+		setVar(player, name, String.valueOf(value), expirationTime);
+	}
+	
+	public static PlayerVar getVarObject(Player player, String name)
+	{
+		if (player.getVariables() == null)
+			return null;
+		
+		return player.getVariables().get(name);
+	}
+	
+	public static long getVarTimeToExpire(Player player, String name)
+	{
+		try
+		{
+			return getVarObject(player, name).getTimeToExpire();
+		}
+		catch (NullPointerException npe)
+		{
+		}
+		
+		return 0;
+	}
+	
+	public static void unsetVar(Player player, String name)
+	{
+		if (name == null)
+			return;
+		
+		// Avoid possible unsetVar that have elements for login
+		if (player == null)
+			return;
+		
+		PlayerVar pv = player.getVariables().remove(name);
+		
+		if (pv != null)
+		{
+			if (name.contains("delete_temp_item"))
+				pv.getOwner().deleteTempItem(Integer.parseInt(pv.getValue()));
+			else if (name.contains("solo_hero"))
+			{
+				pv.getOwner().broadcastCharInfo();
+				pv.getOwner().broadcastUserInfo();
+			}
+			
+			Mysql.set("DELETE FROM character_memo_alt WHERE obj_id=? AND name=? LIMIT 1", pv.getOwner().getObjectId(), name);
+			
+			pv.stopExpireTask();
+		}
+	}
+	
+	public static void deleteExpiredVar(Player player, String name, String value)
+	{
+		if (name == null)
+			return;
+		
+		if (name.contains("delete_temp_item"))
+			player.deleteTempItem(Integer.parseInt(value));
+		/*
+		 * else if(name.contains("solo_hero")) // Useless player.broadcastCharInfo();
+		 */
+		
+		Mysql.set("DELETE FROM character_memo_alt WHERE obj_id=? AND name=? LIMIT 1", player.getObjectId(), name);
+	}
+	
+	public static String getVar(Player player, String name)
+	{
+		PlayerVar pv = getVarObject(player, name);
+		
+		if (pv == null)
+			return null;
+		
+		return pv.getValue();
+	}
+	
+	public static long getVarTimeToExpireSQL(Player player, String name)
+	{
+		long expireTime = 0;
+		try (Connection con = ConnectionPool.getConnection())
+		{
+			PreparedStatement statement = con.prepareStatement("SELECT expire_time FROM character_memo_alt WHERE obj_id = ? AND name = ?");
+			statement.setLong(1, player.getObjectId());
+			statement.setString(2, name);
+			for (ResultSet rset = statement.executeQuery(); rset.next();)
+				expireTime = rset.getLong("expire_time");
+			
+			con.close();
+			statement.close();
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		
+		return expireTime;
+	}
+	
+	public static boolean getVarB(Player player, String name, boolean defaultVal)
+	{
+		PlayerVar pv = getVarObject(player, name);
+		
+		if (pv == null)
+			return defaultVal;
+		
+		return pv.getValueBoolean();
+	}
+	
+	public static boolean getVarB(Player player, String name)
+	{
+		return getVarB(player, name, false);
+	}
+	
+	public long getVarLong(Player player, String name)
+	{
+		return getVarLong(player, name, 0L);
+	}
+	
+	public long getVarLong(Player player, String name, long defaultVal)
+	{
+		long result = defaultVal;
+		String var = getVar(player, name);
+		if (var != null)
+			result = Long.parseLong(var);
+		
+		return result;
+	}
+	
+	public static int getVarInt(Player player, String name)
+	{
+		return getVarInt(player, name, 0);
+	}
+	
+	public static int getVarInt(Player player, String name, int defaultVal)
+	{
+		int result = defaultVal;
+		String var = getVar(player, name);
+		if (var != null)
+		{
+			if (var.equalsIgnoreCase("true"))
+				result = 1;
+			else if (var.equalsIgnoreCase("false"))
+				result = 0;
+			else
+				result = Integer.parseInt(var);
+		}
+		return result;
+	}
+	
+	public static void votedResult(Player player)
+	{
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("SELECT * FROM character_memo_alt WHERE obj_id=? AND name=?");
+			offline.setInt(1, player.getObjectId());
+			rs = offline.executeQuery();
+			boolean hasResult = rs.next();
+			if (!hasResult)
+			{
+				insertVoteSites(player);
+			}
+			
+			con.close();
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+	}
+	
+	public static void insertVoteSites(Player player)
+	{
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("INSERT INTO character_memo_alt (obj_id,name,value,expire_time) VALUES (?,?,?,?)");
+			offline.setInt(1, player.getObjectId());
+			offline.setString(2, "votedSites");
+			offline.setString(3, "0");
+			offline.setLong(4, 0);
+			offline.execute();
+			con.close();
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+	}
+	
+	public static void loadVariables(Player player)
+	{
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("SELECT * FROM character_memo_alt WHERE obj_id =?");
+			offline.setInt(1, player.getObjectId());
+			rs = offline.executeQuery();
+			
+			while (rs.next())
+			{
+				String name = rs.getString("name");
+				String value = rs.getString("value");
+				long expire_time = rs.getLong("expire_time");
+				long curtime = System.currentTimeMillis();
+				
+				if ((expire_time <= curtime) && (expire_time > 0))
+				{
+					deleteExpiredVar(player, name, rs.getString("value")); // TODO: Remove the Var
+					continue;
+				}
+				
+				player.getVariables().put(name, new PlayerVar(player, name, value, expire_time));
+			}
+			
+			con.close();
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+	}
+	
+	public static String getVarValue(Player player, String var, String defaultString)
+	{
+		String value = null;
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("SELECT value FROM character_memo_alt WHERE obj_id = ? AND name = ?");
+			offline.setInt(1, player.getObjectId());
+			offline.setString(2, var);
+			rs = offline.executeQuery();
+			if (rs.next())
+				value = rs.getString("value");
+			
+			con.close();
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+		return value == null ? defaultString : value;
+	}
+	
+	public static String getVarValue(int objectId, String var, String defaultString)
+	{
+		String value = null;
+		Connection con = null;
+		PreparedStatement offline = null;
+		ResultSet rs = null;
+		try
+		{
+			con = ConnectionPool.getConnection();
+			offline = con.prepareStatement("SELECT value FROM character_memo_alt WHERE obj_id = ? AND name = ?");
+			offline.setInt(1, objectId);
+			offline.setString(2, var);
+			rs = offline.executeQuery();
+			if (rs.next())
+				value = rs.getString("value");
+			
+			con.close();
+		}
+		catch (Exception e)
+		{
+			e.printStackTrace();
+		}
+		finally
+		{
+			Mysql.closeQuietly(con, offline, rs);
+		}
+		return value == null ? defaultString : value;
+	}
+	
+}
diff --git a/aCis_gameserver/java/net/sf/l2j/util/RewardHolder.java b/aCis_gameserver/java/net/sf/l2j/util/RewardHolder.java
new file mode 100644
index 0000000..be68616
--- /dev/null
+++ b/aCis_gameserver/java/net/sf/l2j/util/RewardHolder.java
@@ -0,0 +1,49 @@
+package net.sf.l2j.util;
+
+/**
+ * @author Rouxy
+ */
+public class RewardHolder
+{
+	private int itemId;
+	private int count;
+	private int chance;
+	
+	public RewardHolder(int itemId, int count)
+	{
+		this.itemId = itemId;
+		this.count = count;
+		this.chance = 100;
+	}
+	
+	public int getItemId()
+	{
+		return itemId;
+	}
+	
+	public void setItemId(int itemId)
+	{
+		this.itemId = itemId;
+	}
+	
+	public int getCount()
+	{
+		return count;
+	}
+	
+	public void setCount(int count)
+	{
+		this.count = count;
+	}
+	
+	public int getChance()
+	{
+		return chance;
+	}
+	
+	public void setChance(int chance)
+	{
+		this.chance = chance;
+	}
+	
+}
